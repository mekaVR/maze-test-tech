{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst common_1 = require(\"./domain/common\");\n/**\n * Searches for the shortest path from `s` to `t` and returns a list of {@link Direction directions}\n * to get from `s` to `t` or `undefined`, if no path could be found.\n *\n * @param area The area to search\n * @param s The start point\n * @param t The target point\n * @param isWalkable Predicate to decide if a {@link Tile} can be walked. Defaults to {@link Tile.passable}.\n *\n * @returns A list of {@link Direction directions} to get from `s` to `t` or `undefined`, if no path could be found.\n */\n\n\nfunction findPath(area, s, t, isWalkable) {\n  isWalkable = isWalkable || (t => t.passable);\n\n  const start = common_1.Vector.from(s);\n  const target = common_1.Vector.from(t);\n  const openNodes = [];\n  const visited = [];\n\n  for (let x = 0; x < area.width; x++) {\n    visited.push(new Array(area.height).fill(false));\n  }\n\n  let finalNode = undefined;\n  openNodes.push(createNode(start, 0, target));\n\n  do {\n    const node = openNodes.pop();\n\n    if (node.point.equals(target)) {\n      finalNode = node;\n      break;\n    }\n\n    const neighbours = area.neighbours(node.point, common_1.Direction.straights());\n    visited[node.point.x][node.point.y] = true;\n\n    for (let name in neighbours) {\n      const tile = neighbours[name];\n      const direction = common_1.Direction.forName(name);\n      const successorPoint = node.point.translate(direction);\n\n      if (isWalkable(tile) && !visited[successorPoint.x][successorPoint.y]) {\n        const successorIndex = openNodes.findIndex(n => n.point.equals(successorPoint));\n        const successorNode = createNode(successorPoint, node.cost + 1, target, node, direction);\n\n        if (successorIndex === -1) {\n          openNodes.push(successorNode);\n        } else if (node.cost + 1 < openNodes[successorIndex].cost) {\n          openNodes[successorIndex] = successorNode;\n        }\n      }\n    }\n\n    openNodes.sort(compareNodes);\n  } while (openNodes.length > 0);\n\n  return finalNode === undefined ? undefined : buildPath(finalNode);\n}\n\nexports.findPath = findPath;\n\nfunction createNode(point, cost, target, predecessor, direction) {\n  return {\n    point: point,\n    cost: cost,\n    distance: point.distance(target),\n    predecessor: predecessor,\n    direction: direction\n  };\n}\n\nfunction compareNodes(node1, node2) {\n  const v1 = node1.cost + node1.distance;\n  const v2 = node2.cost + node2.distance;\n  return (v1 - v2) * -1;\n}\n\nfunction buildPath(node) {\n  const path = [];\n  let currentNode = node;\n\n  while (currentNode.predecessor !== undefined) {\n    if (currentNode.direction === undefined) {\n      throw new Error(\"Node in path does not have a direction\");\n    }\n\n    path.push(currentNode.direction);\n    currentNode = currentNode.predecessor;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/solver.js"],"names":["Object","defineProperty","exports","value","common_1","require","findPath","area","s","t","isWalkable","passable","start","Vector","from","target","openNodes","visited","x","width","push","Array","height","fill","finalNode","undefined","createNode","node","pop","point","equals","neighbours","Direction","straights","y","name","tile","direction","forName","successorPoint","translate","successorIndex","findIndex","n","successorNode","cost","sort","compareNodes","length","buildPath","predecessor","distance","node1","node2","v1","v2","path","currentNode","Error"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = require(\"./domain/common\");\n/**\n * Searches for the shortest path from `s` to `t` and returns a list of {@link Direction directions}\n * to get from `s` to `t` or `undefined`, if no path could be found.\n *\n * @param area The area to search\n * @param s The start point\n * @param t The target point\n * @param isWalkable Predicate to decide if a {@link Tile} can be walked. Defaults to {@link Tile.passable}.\n *\n * @returns A list of {@link Direction directions} to get from `s` to `t` or `undefined`, if no path could be found.\n */\nfunction findPath(area, s, t, isWalkable) {\n    isWalkable = isWalkable || (t => t.passable);\n    const start = common_1.Vector.from(s);\n    const target = common_1.Vector.from(t);\n    const openNodes = [];\n    const visited = [];\n    for (let x = 0; x < area.width; x++) {\n        visited.push(new Array(area.height).fill(false));\n    }\n    let finalNode = undefined;\n    openNodes.push(createNode(start, 0, target));\n    do {\n        const node = openNodes.pop();\n        if (node.point.equals(target)) {\n            finalNode = node;\n            break;\n        }\n        const neighbours = area.neighbours(node.point, common_1.Direction.straights());\n        visited[node.point.x][node.point.y] = true;\n        for (let name in neighbours) {\n            const tile = neighbours[name];\n            const direction = common_1.Direction.forName(name);\n            const successorPoint = node.point.translate(direction);\n            if (isWalkable(tile) && !visited[successorPoint.x][successorPoint.y]) {\n                const successorIndex = openNodes.findIndex(n => n.point.equals(successorPoint));\n                const successorNode = createNode(successorPoint, node.cost + 1, target, node, direction);\n                if (successorIndex === -1) {\n                    openNodes.push(successorNode);\n                }\n                else if (node.cost + 1 < openNodes[successorIndex].cost) {\n                    openNodes[successorIndex] = successorNode;\n                }\n            }\n        }\n        openNodes.sort(compareNodes);\n    } while (openNodes.length > 0);\n    return finalNode === undefined ? undefined : buildPath(finalNode);\n}\nexports.findPath = findPath;\nfunction createNode(point, cost, target, predecessor, direction) {\n    return {\n        point: point,\n        cost: cost,\n        distance: point.distance(target),\n        predecessor: predecessor,\n        direction: direction\n    };\n}\nfunction compareNodes(node1, node2) {\n    const v1 = node1.cost + node1.distance;\n    const v2 = node2.cost + node2.distance;\n    return (v1 - v2) * -1;\n}\nfunction buildPath(node) {\n    const path = [];\n    let currentNode = node;\n    while (currentNode.predecessor !== undefined) {\n        if (currentNode.direction === undefined) {\n            throw new Error(\"Node in path does not have a direction\");\n        }\n        path.push(currentNode.direction);\n        currentNode = currentNode.predecessor;\n    }\n    return path;\n}\n"]},"metadata":{},"sourceType":"script"}