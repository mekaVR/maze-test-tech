{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst util_1 = require(\"../util\");\n\nconst _generators = {};\nconst _configFields = {};\n/**\n * Registers the given {@link AreaGenerator} and the fields describing\n * its config (without the fields in {@link GeneratorConfig}). This allows\n * other utility methods to retrieve the registered generator and construct\n * its config.\n *\n * @see {@link generators}\n * @see {@link generator}\n * @see {@link parseGenerator}\n */\n\nfunction registerGenerator(name, generator, configFields) {\n  _generators[name] = generator;\n\n  if (configFields !== undefined) {\n    _configFields[name] = configFields;\n  }\n}\n\nexports.registerGenerator = registerGenerator;\n/**\n * @returns A list of all {@link registerGenerator registered} and their config\n *      {@link Field fields} (if provided) as tuples.\n */\n\nfunction generators() {\n  let result = [];\n\n  for (let name in _generators) {\n    result.push({\n      name: name,\n      generator: _generators[name],\n      configFields: _configFields[name]\n    });\n  }\n\n  return result;\n}\n\nexports.generators = generators;\n/**\n * Parses the given data as {@link AreaGenerator} with config (if possible).\n *\n * The given data must be string with format `<generator name>[:<config data>]`\n * or an object, where the first key is the generator name and its value is\n * the config data.\n *\n * {@link configFrom} is used to create a config object from the config data.\n *\n * @param data The generator data to be parsed\n *\n * @throws An error, if the config data can not be parsed.\n */\n\nfunction parseGenerator(data) {\n  let generatorName;\n  let configData;\n\n  if (typeof data === \"string\") {\n    const parts = data.split(\":\");\n    generatorName = parts[0];\n    configData = parts[1];\n  } else {\n    generatorName = Object.keys(data)[0];\n    configData = data[generatorName];\n  }\n\n  const _generator = generator(generatorName);\n\n  let config = undefined;\n\n  if (configData !== undefined && _configFields.hasOwnProperty(_generator.name)) {\n    try {\n      config = util_1.configFrom(configData, _configFields[_generator.name]);\n    } catch (error) {\n      throw new Error(`Error parsing config for generator ${generatorName}: ${error.message}`);\n    }\n  }\n\n  return {\n    generator: _generator,\n    config: config\n  };\n}\n\nexports.parseGenerator = parseGenerator;\n/**\n * @param name The algorithm name\n *\n * @returns The {@link AreaGenerator} with the given name.\n *\n * @throws An error, if no generator with the given name can be found.\n */\n\nfunction generator(name) {\n  const generator = _generators[name];\n\n  if (generator === undefined) {\n    throw new Error(`No generator with name ${name} could be found`);\n  }\n\n  return generator;\n}\n\nexports.generator = generator;\n/**\n * Utility class representing a tile inside an area that has been\n * visitied, including the walkable directions outgoing from the tile.\n *\n * Used by several area generation algorithms.\n */\n\nclass VisitedTile {\n  constructor(point, walkableDirections) {\n    this.point = point;\n    this.walkableDirections = lodash_1.default.shuffle(walkableDirections);\n  }\n  /**\n   * @returns `true`, if there are walkable directions remaining.\n   */\n\n\n  hasNext() {\n    return this.walkableDirections.length > 0;\n  }\n  /**\n   * @returns The next walkable direction, moving the iterator forwards.\n   *\n   * @throws An error, if no walkable directions are left (see {@link hasNext}).\n   */\n\n\n  next() {\n    let next = this.walkableDirections.pop();\n\n    if (next === undefined) {\n      throw new Error(\"No walkable directions left\");\n    }\n\n    return next;\n  }\n\n}\n\nexports.VisitedTile = VisitedTile;","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/generator/base.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","util_1","_generators","_configFields","registerGenerator","name","generator","configFields","undefined","generators","result","push","parseGenerator","data","generatorName","configData","parts","split","keys","_generator","config","hasOwnProperty","configFrom","error","Error","message","VisitedTile","constructor","point","walkableDirections","default","shuffle","hasNext","length","next","pop"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst util_1 = require(\"../util\");\nconst _generators = {};\nconst _configFields = {};\n/**\n * Registers the given {@link AreaGenerator} and the fields describing\n * its config (without the fields in {@link GeneratorConfig}). This allows\n * other utility methods to retrieve the registered generator and construct\n * its config.\n *\n * @see {@link generators}\n * @see {@link generator}\n * @see {@link parseGenerator}\n */\nfunction registerGenerator(name, generator, configFields) {\n    _generators[name] = generator;\n    if (configFields !== undefined) {\n        _configFields[name] = configFields;\n    }\n}\nexports.registerGenerator = registerGenerator;\n/**\n * @returns A list of all {@link registerGenerator registered} and their config\n *      {@link Field fields} (if provided) as tuples.\n */\nfunction generators() {\n    let result = [];\n    for (let name in _generators) {\n        result.push({\n            name: name,\n            generator: _generators[name],\n            configFields: _configFields[name]\n        });\n    }\n    return result;\n}\nexports.generators = generators;\n/**\n * Parses the given data as {@link AreaGenerator} with config (if possible).\n *\n * The given data must be string with format `<generator name>[:<config data>]`\n * or an object, where the first key is the generator name and its value is\n * the config data.\n *\n * {@link configFrom} is used to create a config object from the config data.\n *\n * @param data The generator data to be parsed\n *\n * @throws An error, if the config data can not be parsed.\n */\nfunction parseGenerator(data) {\n    let generatorName;\n    let configData;\n    if (typeof data === \"string\") {\n        const parts = data.split(\":\");\n        generatorName = parts[0];\n        configData = parts[1];\n    }\n    else {\n        generatorName = Object.keys(data)[0];\n        configData = data[generatorName];\n    }\n    const _generator = generator(generatorName);\n    let config = undefined;\n    if (configData !== undefined && _configFields.hasOwnProperty(_generator.name)) {\n        try {\n            config = util_1.configFrom(configData, _configFields[_generator.name]);\n        }\n        catch (error) {\n            throw new Error(`Error parsing config for generator ${generatorName}: ${error.message}`);\n        }\n    }\n    return { generator: _generator, config: config };\n}\nexports.parseGenerator = parseGenerator;\n/**\n * @param name The algorithm name\n *\n * @returns The {@link AreaGenerator} with the given name.\n *\n * @throws An error, if no generator with the given name can be found.\n */\nfunction generator(name) {\n    const generator = _generators[name];\n    if (generator === undefined) {\n        throw new Error(`No generator with name ${name} could be found`);\n    }\n    return generator;\n}\nexports.generator = generator;\n/**\n * Utility class representing a tile inside an area that has been\n * visitied, including the walkable directions outgoing from the tile.\n *\n * Used by several area generation algorithms.\n */\nclass VisitedTile {\n    constructor(point, walkableDirections) {\n        this.point = point;\n        this.walkableDirections = lodash_1.default.shuffle(walkableDirections);\n    }\n    /**\n     * @returns `true`, if there are walkable directions remaining.\n     */\n    hasNext() {\n        return this.walkableDirections.length > 0;\n    }\n    /**\n     * @returns The next walkable direction, moving the iterator forwards.\n     *\n     * @throws An error, if no walkable directions are left (see {@link hasNext}).\n     */\n    next() {\n        let next = this.walkableDirections.pop();\n        if (next === undefined) {\n            throw new Error(\"No walkable directions left\");\n        }\n        return next;\n    }\n}\nexports.VisitedTile = VisitedTile;\n"]},"metadata":{},"sourceType":"script"}