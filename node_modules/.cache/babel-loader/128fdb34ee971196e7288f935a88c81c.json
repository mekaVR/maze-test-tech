{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base_1 = require(\"./base\");\n\nconst area_1 = require(\"../domain/area\");\n\nconst common_1 = require(\"../domain/common\");\n/**\n * Surrounds an area with a solid wall, which may increase the areas size.\n * This modifier has no separate config.\n *\n * Edges that already are solid (only consist of wall tiles) are skipped.\n *\n * Example:\n * ```\n *                 ┏━━━━━━━━━━━┓\n * ┏━━━━━━━━━┓     ┃ # # # # # ┃\n * ┃       # ┃     ┃ #       # ┃\n * ┃ # #   # ┃  => ┃ # # #   # ┃\n * ┃       # ┃     ┃ #       # ┃\n * ┃ # # # # ┃     ┃ # # # # # ┃\n * ┗━━━━━━━━━┛     ┗━━━━━━━━━━━┛\n * ```\n *\n * @returns A new {@link Area} instance that is completely surrounded\n *      by wall tiles.\n */\n\n\nexports.Emmure = emmure;\nbase_1.registerModifier(\"Emmure\", exports.Emmure);\n\nfunction emmure(area, _) {\n  let borders = {\n    \"Up\": [new common_1.Vector(0, 0), common_1.Direction.Right],\n    \"Left\": [new common_1.Vector(0, 0), common_1.Direction.Down],\n    \"Right\": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Up],\n    \"Down\": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Left]\n  };\n  let wallsNeeded = {};\n\n  for (let borderDirection in borders) {\n    let [point, walkDirection] = borders[borderDirection];\n    let needsWall = 0;\n\n    while (area.contains(point)) {\n      if (area.get(point).passable) {\n        needsWall = 1;\n        break;\n      }\n\n      point = point.translate(walkDirection);\n    }\n\n    wallsNeeded[borderDirection] = needsWall;\n  }\n\n  let xOffset = wallsNeeded[\"Left\"];\n  let yOffset = wallsNeeded[\"Up\"];\n  let emmuredArea = new area_1.Area({\n    width: area.width + xOffset + wallsNeeded[\"Right\"],\n    height: area.height + yOffset + wallsNeeded[\"Down\"]\n  });\n  area.forEach((t, p) => emmuredArea.set({\n    x: p.x + xOffset,\n    y: p.y + yOffset\n  }, t));\n\n  for (let point of emmuredArea.points()) {\n    if (emmuredArea.get(point) === area_1.Tile.Empty) {\n      emmuredArea.set(point, area_1.Tile.Wall);\n    }\n  }\n\n  return emmuredArea;\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/modifier/simple.js"],"names":["Object","defineProperty","exports","value","base_1","require","area_1","common_1","Emmure","emmure","registerModifier","area","_","borders","Vector","Direction","Right","Down","width","height","Up","Left","wallsNeeded","borderDirection","point","walkDirection","needsWall","contains","get","passable","translate","xOffset","yOffset","emmuredArea","Area","forEach","t","p","set","x","y","points","Tile","Empty","Wall"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = require(\"./base\");\nconst area_1 = require(\"../domain/area\");\nconst common_1 = require(\"../domain/common\");\n/**\n * Surrounds an area with a solid wall, which may increase the areas size.\n * This modifier has no separate config.\n *\n * Edges that already are solid (only consist of wall tiles) are skipped.\n *\n * Example:\n * ```\n *                 ┏━━━━━━━━━━━┓\n * ┏━━━━━━━━━┓     ┃ # # # # # ┃\n * ┃       # ┃     ┃ #       # ┃\n * ┃ # #   # ┃  => ┃ # # #   # ┃\n * ┃       # ┃     ┃ #       # ┃\n * ┃ # # # # ┃     ┃ # # # # # ┃\n * ┗━━━━━━━━━┛     ┗━━━━━━━━━━━┛\n * ```\n *\n * @returns A new {@link Area} instance that is completely surrounded\n *      by wall tiles.\n */\nexports.Emmure = emmure;\nbase_1.registerModifier(\"Emmure\", exports.Emmure);\nfunction emmure(area, _) {\n    let borders = {\n        \"Up\": [new common_1.Vector(0, 0), common_1.Direction.Right],\n        \"Left\": [new common_1.Vector(0, 0), common_1.Direction.Down],\n        \"Right\": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Up],\n        \"Down\": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Left]\n    };\n    let wallsNeeded = {};\n    for (let borderDirection in borders) {\n        let [point, walkDirection] = borders[borderDirection];\n        let needsWall = 0;\n        while (area.contains(point)) {\n            if (area.get(point).passable) {\n                needsWall = 1;\n                break;\n            }\n            point = point.translate(walkDirection);\n        }\n        wallsNeeded[borderDirection] = needsWall;\n    }\n    let xOffset = wallsNeeded[\"Left\"];\n    let yOffset = wallsNeeded[\"Up\"];\n    let emmuredArea = new area_1.Area({\n        width: area.width + xOffset + wallsNeeded[\"Right\"],\n        height: area.height + yOffset + wallsNeeded[\"Down\"]\n    });\n    area.forEach((t, p) => emmuredArea.set({ x: p.x + xOffset, y: p.y + yOffset }, t));\n    for (let point of emmuredArea.points()) {\n        if (emmuredArea.get(point) === area_1.Tile.Empty) {\n            emmuredArea.set(point, area_1.Tile.Wall);\n        }\n    }\n    return emmuredArea;\n}\n"]},"metadata":{},"sourceType":"script"}