{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst area_1 = require(\"../domain/area\");\n\nconst base_1 = require(\"./base\");\n\nconst common_1 = require(\"../domain/common\");\n/**\n * Area generation algorithm using on a depth first\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker recursive backtracker}\n * algorithm. This algorithm has no separate config.\n *\n * Generates dense, perfect areas with low branching factor and\n * many long corridors. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃               #       #       ┃\n * ┃ # # # #   # # #   #   #   #   ┃\n * ┃           #       #       #   ┃\n * ┃   # # # # #   # # # # # # #   ┃\n * ┃   #       #               #   ┃\n * ┃   #   #   #   # # # # # # #   ┃\n * ┃       #   #   #           #   ┃\n * ┃   # # #   #   #   # # # # #   ┃\n * ┃       #   #   #           #   ┃\n * ┃ # #   #   #   # # # # #   #   ┃\n * ┃       #       #       #   #   ┃\n * ┃   # # # # # # # # #   #   #   ┃\n * ┃   #           #       #       ┃\n * ┃   # # #   #   #   #   # # # # ┃\n * ┃           #       #           ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\n\n\nexports.RecursiveBacktracker = recursiveBacktracker;\nbase_1.registerGenerator(\"RecursiveBacktracker\", exports.RecursiveBacktracker);\n\nfunction recursiveBacktracker(config) {\n  const area = new area_1.Area(config.size, area_1.Tile.Wall);\n  const start = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);\n  recursiveBacktrack(area, start);\n  return area;\n}\n/** @ignore */\n\n\nfunction recursiveBacktrack(area, start) {\n  let stack = [new base_1.VisitedTile(start, common_1.Direction.straights())];\n\n  while (stack.length > 0) {\n    let tile = stack.pop();\n    area.set(tile.point, area_1.Tile.Floor);\n\n    while (tile.hasNext()) {\n      let direction = tile.next();\n      let nextPoint = tile.point.translate(direction, 2);\n\n      if (area.contains(nextPoint) && !area.get(nextPoint).passable) {\n        area.set(tile.point.translate(direction), area_1.Tile.Floor);\n        stack.push(tile);\n        stack.push(new base_1.VisitedTile(nextPoint, common_1.Direction.straights()));\n        break;\n      }\n    }\n  }\n}\n\nexports.recursiveBacktrack = recursiveBacktrack;\n/**\n * Area generation algorithm based on\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal's_algorithm Randomized Kruskal's}.\n * This algorithm has no separate config.\n *\n * Generates dense, perfect areas with high branching factor and\n * many deadends that are easy to solve. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃                           #   ┃\n * ┃ # #   # # # # # # #   # # #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # # #   # # #   # # #   # # ┃\n * ┃       #   #                   ┃\n * ┃   #   #   #   # # # # #   # # ┃\n * ┃   #           #       #       ┃\n * ┃ # #   #   #   # # #   #   #   ┃\n * ┃   #   #   #       #   #   #   ┃\n * ┃   # # # # # # #   #   # # # # ┃\n * ┃                               ┃\n * ┃ # #   # # #   # # # # # # # # ┃\n * ┃       #                       ┃\n * ┃ # # # # # #   # # # # # # #   ┃\n * ┃               #               ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\n\nexports.RandomizedKruskal = randomizedKruskal;\nbase_1.registerGenerator(\"RandomizedKruskal\", exports.RandomizedKruskal);\n\nfunction randomizedKruskal(config) {\n  const area = new area_1.Area(config.size);\n  const subSets = [];\n  let walls = [];\n\n  for (let point of area.points()) {\n    if (point.x % 2 == 1 || point.y % 2 == 1) {\n      area.set(point, area_1.Tile.Wall);\n      walls.push(new base_1.VisitedTile(point, [common_1.Direction.Up, common_1.Direction.Right]));\n    } else {\n      area.set(point, area_1.Tile.Floor);\n      let subSet = new Set();\n      subSet.add(point);\n      subSets.push(subSet);\n    }\n  }\n\n  walls = lodash_1.default.shuffle(walls);\n\n  const findSubSet = p => {\n    for (let s of subSets) {\n      for (let pS of s) {\n        if (lodash_1.default.isEqual(p, pS)) {\n          return s;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  while (walls.length > 0) {\n    let wall = walls.pop();\n\n    if (wall.hasNext()) {\n      let direction = wall.next();\n      let set1 = findSubSet(wall.point.translate(direction));\n      let set2 = findSubSet(wall.point.translate(direction.opposite()));\n\n      if (set1 !== undefined && set2 !== undefined && set1 !== set2) {\n        area.set(wall.point, area_1.Tile.Floor);\n        set2.forEach(p => set1.add(p));\n        lodash_1.default.remove(subSets, s => s === set2);\n      }\n\n      walls.push(wall);\n    }\n\n    walls = lodash_1.default.shuffle(walls);\n  }\n\n  return area;\n}\n/**\n * Area generation algorithm based on\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim's_algorithm Randomized Prim's}.\n * This algorithm has no separate config.\n *\n * Generates dense, perfect areas with high branching factor and\n * many deadends that are easy to solve. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃   #   #   #           #   #   ┃\n * ┃   #   #   # # #   # # #   #   ┃\n * ┃           #   #           #   ┃\n * ┃ # # # #   #   # # #   # # #   ┃\n * ┃                       #   #   ┃\n * ┃ # # # # # # # #   #   #   #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # # #   # # #   # # #   # # ┃\n * ┃   #   #   #   #       #       ┃\n * ┃   #   #   #   #   # # # # #   ┃\n * ┃   #   #   #           #       ┃\n * ┃   #   #   # # #   # # #   # # ┃\n * ┃           #                   ┃\n * ┃ # # # #   # # #   #   #   # # ┃\n * ┃                   #   #       ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\n\n\nexports.RandomizedPrim = randomizedPrim;\nbase_1.registerGenerator(\"RandomizedPrim\", exports.RandomizedPrim);\n\nfunction randomizedPrim(config) {\n  const area = new area_1.Area(config.size, area_1.Tile.Wall);\n  const walls = [];\n  const point = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);\n  area.set(point, area_1.Tile.Floor); // TODO Remove duplicated code\n\n  common_1.Direction.straights().forEach(d => {\n    const p = point.translate(d);\n\n    if (area.contains(p)) {\n      walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));\n    }\n  });\n\n  while (walls.length > 0) {\n    let index = lodash_1.default.random(walls.length - 1);\n    let wall = walls[index];\n    let direction = wall.next();\n    let neighbour1 = wall.point.translate(direction);\n    let neighbour2 = wall.point.translate(direction.opposite());\n\n    if (area.contains(neighbour1) && area.contains(neighbour2) && area.get(neighbour1).passable !== area.get(neighbour2).passable) {\n      let unvisited = area.get(neighbour1).passable ? neighbour2 : neighbour1;\n      area.set(wall.point, area_1.Tile.Floor);\n      area.set(unvisited, area_1.Tile.Floor); // TODO Remove duplicated code\n\n      common_1.Direction.straights().forEach(d => {\n        const p = unvisited.translate(d);\n\n        if (area.contains(p)) {\n          walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));\n        }\n      });\n    }\n\n    if (!wall.hasNext()) {\n      walls.splice(index, 1);\n    }\n  }\n\n  return area;\n}\n/**\n * Generates a completely random {@link Area}, where each\n * tile has a 50/50 change to be floor or wall.\n */\n\n\nexports.RandomArea = random;\nbase_1.registerGenerator(\"RandomArea\", exports.RandomArea);\n\nfunction random(config) {\n  const area = new area_1.Area(config.size);\n  let points = lodash_1.default.shuffle(Array.from(area.points()));\n  points.forEach(p => area.set(p, lodash_1.default.random() > 0.5 ? area_1.Tile.Floor : area_1.Tile.Wall));\n  return area;\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/generator/simple.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","area_1","base_1","common_1","RecursiveBacktracker","recursiveBacktracker","registerGenerator","config","area","Area","size","Tile","Wall","start","Vector","random","p","x","y","recursiveBacktrack","stack","VisitedTile","Direction","straights","length","tile","pop","set","point","Floor","hasNext","direction","next","nextPoint","translate","contains","get","passable","push","RandomizedKruskal","randomizedKruskal","subSets","walls","points","Up","Right","subSet","Set","add","default","shuffle","findSubSet","s","pS","isEqual","undefined","wall","set1","set2","opposite","forEach","remove","RandomizedPrim","randomizedPrim","d","index","neighbour1","neighbour2","unvisited","splice","RandomArea","Array","from"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst area_1 = require(\"../domain/area\");\nconst base_1 = require(\"./base\");\nconst common_1 = require(\"../domain/common\");\n/**\n * Area generation algorithm using on a depth first\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker recursive backtracker}\n * algorithm. This algorithm has no separate config.\n *\n * Generates dense, perfect areas with low branching factor and\n * many long corridors. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃               #       #       ┃\n * ┃ # # # #   # # #   #   #   #   ┃\n * ┃           #       #       #   ┃\n * ┃   # # # # #   # # # # # # #   ┃\n * ┃   #       #               #   ┃\n * ┃   #   #   #   # # # # # # #   ┃\n * ┃       #   #   #           #   ┃\n * ┃   # # #   #   #   # # # # #   ┃\n * ┃       #   #   #           #   ┃\n * ┃ # #   #   #   # # # # #   #   ┃\n * ┃       #       #       #   #   ┃\n * ┃   # # # # # # # # #   #   #   ┃\n * ┃   #           #       #       ┃\n * ┃   # # #   #   #   #   # # # # ┃\n * ┃           #       #           ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\nexports.RecursiveBacktracker = recursiveBacktracker;\nbase_1.registerGenerator(\"RecursiveBacktracker\", exports.RecursiveBacktracker);\nfunction recursiveBacktracker(config) {\n    const area = new area_1.Area(config.size, area_1.Tile.Wall);\n    const start = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);\n    recursiveBacktrack(area, start);\n    return area;\n}\n/** @ignore */\nfunction recursiveBacktrack(area, start) {\n    let stack = [new base_1.VisitedTile(start, common_1.Direction.straights())];\n    while (stack.length > 0) {\n        let tile = stack.pop();\n        area.set(tile.point, area_1.Tile.Floor);\n        while (tile.hasNext()) {\n            let direction = tile.next();\n            let nextPoint = tile.point.translate(direction, 2);\n            if (area.contains(nextPoint) && !area.get(nextPoint).passable) {\n                area.set(tile.point.translate(direction), area_1.Tile.Floor);\n                stack.push(tile);\n                stack.push(new base_1.VisitedTile(nextPoint, common_1.Direction.straights()));\n                break;\n            }\n        }\n    }\n}\nexports.recursiveBacktrack = recursiveBacktrack;\n/**\n * Area generation algorithm based on\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal's_algorithm Randomized Kruskal's}.\n * This algorithm has no separate config.\n *\n * Generates dense, perfect areas with high branching factor and\n * many deadends that are easy to solve. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃                           #   ┃\n * ┃ # #   # # # # # # #   # # #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # # #   # # #   # # #   # # ┃\n * ┃       #   #                   ┃\n * ┃   #   #   #   # # # # #   # # ┃\n * ┃   #           #       #       ┃\n * ┃ # #   #   #   # # #   #   #   ┃\n * ┃   #   #   #       #   #   #   ┃\n * ┃   # # # # # # #   #   # # # # ┃\n * ┃                               ┃\n * ┃ # #   # # #   # # # # # # # # ┃\n * ┃       #                       ┃\n * ┃ # # # # # #   # # # # # # #   ┃\n * ┃               #               ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\nexports.RandomizedKruskal = randomizedKruskal;\nbase_1.registerGenerator(\"RandomizedKruskal\", exports.RandomizedKruskal);\nfunction randomizedKruskal(config) {\n    const area = new area_1.Area(config.size);\n    const subSets = [];\n    let walls = [];\n    for (let point of area.points()) {\n        if (point.x % 2 == 1 || point.y % 2 == 1) {\n            area.set(point, area_1.Tile.Wall);\n            walls.push(new base_1.VisitedTile(point, [common_1.Direction.Up, common_1.Direction.Right]));\n        }\n        else {\n            area.set(point, area_1.Tile.Floor);\n            let subSet = new Set();\n            subSet.add(point);\n            subSets.push(subSet);\n        }\n    }\n    walls = lodash_1.default.shuffle(walls);\n    const findSubSet = (p) => {\n        for (let s of subSets) {\n            for (let pS of s) {\n                if (lodash_1.default.isEqual(p, pS)) {\n                    return s;\n                }\n            }\n        }\n        return undefined;\n    };\n    while (walls.length > 0) {\n        let wall = walls.pop();\n        if (wall.hasNext()) {\n            let direction = wall.next();\n            let set1 = findSubSet(wall.point.translate(direction));\n            let set2 = findSubSet(wall.point.translate(direction.opposite()));\n            if (set1 !== undefined && set2 !== undefined && set1 !== set2) {\n                area.set(wall.point, area_1.Tile.Floor);\n                set2.forEach(p => set1.add(p));\n                lodash_1.default.remove(subSets, s => s === set2);\n            }\n            walls.push(wall);\n        }\n        walls = lodash_1.default.shuffle(walls);\n    }\n    return area;\n}\n/**\n * Area generation algorithm based on\n * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim's_algorithm Randomized Prim's}.\n * This algorithm has no separate config.\n *\n * Generates dense, perfect areas with high branching factor and\n * many deadends that are easy to solve. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃   #   #   #           #   #   ┃\n * ┃   #   #   # # #   # # #   #   ┃\n * ┃           #   #           #   ┃\n * ┃ # # # #   #   # # #   # # #   ┃\n * ┃                       #   #   ┃\n * ┃ # # # # # # # #   #   #   #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # # #   # # #   # # #   # # ┃\n * ┃   #   #   #   #       #       ┃\n * ┃   #   #   #   #   # # # # #   ┃\n * ┃   #   #   #           #       ┃\n * ┃   #   #   # # #   # # #   # # ┃\n * ┃           #                   ┃\n * ┃ # # # #   # # #   #   #   # # ┃\n * ┃                   #   #       ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n */\nexports.RandomizedPrim = randomizedPrim;\nbase_1.registerGenerator(\"RandomizedPrim\", exports.RandomizedPrim);\nfunction randomizedPrim(config) {\n    const area = new area_1.Area(config.size, area_1.Tile.Wall);\n    const walls = [];\n    const point = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);\n    area.set(point, area_1.Tile.Floor);\n    // TODO Remove duplicated code\n    common_1.Direction.straights().forEach(d => {\n        const p = point.translate(d);\n        if (area.contains(p)) {\n            walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));\n        }\n    });\n    while (walls.length > 0) {\n        let index = lodash_1.default.random(walls.length - 1);\n        let wall = walls[index];\n        let direction = wall.next();\n        let neighbour1 = wall.point.translate(direction);\n        let neighbour2 = wall.point.translate(direction.opposite());\n        if (area.contains(neighbour1) && area.contains(neighbour2) && area.get(neighbour1).passable !== area.get(neighbour2).passable) {\n            let unvisited = area.get(neighbour1).passable ? neighbour2 : neighbour1;\n            area.set(wall.point, area_1.Tile.Floor);\n            area.set(unvisited, area_1.Tile.Floor);\n            // TODO Remove duplicated code\n            common_1.Direction.straights().forEach(d => {\n                const p = unvisited.translate(d);\n                if (area.contains(p)) {\n                    walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));\n                }\n            });\n        }\n        if (!wall.hasNext()) {\n            walls.splice(index, 1);\n        }\n    }\n    return area;\n}\n/**\n * Generates a completely random {@link Area}, where each\n * tile has a 50/50 change to be floor or wall.\n */\nexports.RandomArea = random;\nbase_1.registerGenerator(\"RandomArea\", exports.RandomArea);\nfunction random(config) {\n    const area = new area_1.Area(config.size);\n    let points = lodash_1.default.shuffle(Array.from(area.points()));\n    points.forEach(p => area.set(p, lodash_1.default.random() > 0.5 ? area_1.Tile.Floor : area_1.Tile.Wall));\n    return area;\n}\n"]},"metadata":{},"sourceType":"script"}