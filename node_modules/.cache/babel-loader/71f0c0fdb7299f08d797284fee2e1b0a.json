{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst common_1 = require(\"./common\");\n/**\n * Represents tiles inside an {@link Area}. Has a name for\n * identification and the information if it is passable or\n * not, which is used by several algorithms.\n *\n * Provides default instances for floor, wall and empty\n * tiles.\n */\n\n\nclass Tile {\n  constructor(name, passable) {\n    this.name = name;\n    this.passable = passable;\n  }\n  /**\n   * Creates a new passable tile for the given name.\n   */\n\n\n  static passable(name) {\n    return new Tile(name, true);\n  }\n  /**\n   * Creates a new impassable tile for the given name.\n   */\n\n\n  static impassable(name) {\n    return new Tile(name, false);\n  }\n\n}\n\nexports.Tile = Tile;\n/** Default instance for empty, impassable tiles. */\n\nTile.Empty = Tile.impassable(\"Empty\");\n/** Default instance for passable tiles. */\n\nTile.Floor = Tile.passable(\"Floor\");\n/** Default instance for impassable tiles. */\n\nTile.Wall = Tile.impassable(\"Wall\");\n\nclass Area {\n  /**\n   * Creates a new area with the given {@link Size} filled\n   * with {@link Tile tiles} given as `initialTile`.\n   */\n  constructor(size, initialTile = Tile.Empty) {\n    this.tiles = [];\n\n    for (let x = 0; x < size.width; x++) {\n      this.tiles[x] = [];\n\n      for (let y = 0; y < size.height; y++) {\n        this.tiles[x][y] = initialTile;\n      }\n    }\n  }\n\n  get width() {\n    return this.tiles.length;\n  }\n\n  get height() {\n    return this.tiles[0].length;\n  }\n\n  get size() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n  /**\n   * Generates all {@link Vector points} contained by this area.\n   */\n\n\n  *points() {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        yield new common_1.Vector(x, y);\n      }\n    }\n  }\n  /**\n   * Generates all {@link Tile tile}, {@link Vector point} tuples\n   * contained by this area.\n   */\n\n\n  *cells() {\n    for (let p of this.points()) {\n      yield [this.get(p), p];\n    }\n  }\n  /**\n   * Performs the given action for all tiles contained by\n   * this area.\n   */\n\n\n  forEach(consumer) {\n    for (let [t, p] of this.cells()) {\n      consumer(t, p);\n    }\n  }\n\n  get(point) {\n    return this.tiles[point.x][point.y];\n  }\n\n  set(point, tile) {\n    this.tiles[point.x][point.y] = tile;\n  }\n\n  contains(point) {\n    const x = point.x;\n    const y = point.y;\n    return x >= 0 && x < this.width && y >= 0 && y < this.height;\n  }\n  /**\n   * Returns all {@link Neighbours} of `point` for the given\n   * {@link Direction Directions}.\n   *\n   * @param point The point to get the nieghbours for\n   * @param directions The directions to select the neighbours.\n   *      Defaults to {@link Direction.all}.\n   */\n\n\n  neighbours(point, directions) {\n    let neighbours = {};\n    directions = directions || common_1.Direction.all();\n\n    for (let direction of directions) {\n      let newPoint = point.translate(direction);\n\n      if (this.contains(newPoint)) {\n        neighbours[direction.name] = this.get(newPoint);\n      }\n    }\n\n    return neighbours;\n  }\n  /**\n   * Set all points containing {@link Tile.Empty} to the given {@link Tile}.\n   */\n\n\n  fill(tile) {\n    for (let point of this.points()) {\n      if (this.get(point) === Tile.Empty) {\n        this.set(point, tile);\n      }\n    }\n  }\n\n}\n\nexports.Area = Area;\n/**\n * Performs flood filling on the given {@link Area} using `predicate`\n * to determine if a {@link Tile} is walkable.\n *\n * Results in an array of *sections*, where a section is a set of\n * {@link Vector points} where any point has a path to any other point.\n * This means, that no section has a path to another section.\n *\n * @param area The area to flood fill\n * @param predicate A function to determine if a tile is walkable\n *\n * @returns A two-dimensional array of {@link Vector points}, representing\n *      the sections of the area.\n */\n\nfunction floodFill(area, predicate) {\n  const sections = [];\n  const points = lodash_1.default.shuffle(Array.from(area.points()));\n  let start = points.find(p => predicate(area.get(p)));\n\n  while (start !== undefined) {\n    const section = [];\n    const stack = [start];\n\n    while (stack.length > 0) {\n      const point = stack.pop();\n      section.push(point);\n\n      for (let direction of common_1.Direction.straights()) {\n        const neighbour = point.translate(direction); // TODO Can this be cleaned?\n\n        if (area.contains(neighbour) && predicate(area.get(neighbour)) && !section.some(p => p.x === neighbour.x && p.y === neighbour.y)) {\n          stack.push(neighbour);\n        }\n      }\n    }\n\n    sections.push(section); // TODO Can this be cleaned?\n\n    start = points.find(s => predicate(area.get(s)) && !sections.some(sec => sec.some(p => p.x === s.x && p.y === s.y)));\n  }\n\n  return sections;\n}\n\nexports.floodFill = floodFill;","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/domain/area.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","common_1","Tile","constructor","name","passable","impassable","Empty","Floor","Wall","Area","size","initialTile","tiles","x","width","y","height","length","points","Vector","cells","p","get","forEach","consumer","t","point","set","tile","contains","neighbours","directions","Direction","all","direction","newPoint","translate","fill","floodFill","area","predicate","sections","default","shuffle","Array","from","start","find","undefined","section","stack","pop","push","straights","neighbour","some","s","sec"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst common_1 = require(\"./common\");\n/**\n * Represents tiles inside an {@link Area}. Has a name for\n * identification and the information if it is passable or\n * not, which is used by several algorithms.\n *\n * Provides default instances for floor, wall and empty\n * tiles.\n */\nclass Tile {\n    constructor(name, passable) {\n        this.name = name;\n        this.passable = passable;\n    }\n    /**\n     * Creates a new passable tile for the given name.\n     */\n    static passable(name) {\n        return new Tile(name, true);\n    }\n    /**\n     * Creates a new impassable tile for the given name.\n     */\n    static impassable(name) {\n        return new Tile(name, false);\n    }\n}\nexports.Tile = Tile;\n/** Default instance for empty, impassable tiles. */\nTile.Empty = Tile.impassable(\"Empty\");\n/** Default instance for passable tiles. */\nTile.Floor = Tile.passable(\"Floor\");\n/** Default instance for impassable tiles. */\nTile.Wall = Tile.impassable(\"Wall\");\nclass Area {\n    /**\n     * Creates a new area with the given {@link Size} filled\n     * with {@link Tile tiles} given as `initialTile`.\n     */\n    constructor(size, initialTile = Tile.Empty) {\n        this.tiles = [];\n        for (let x = 0; x < size.width; x++) {\n            this.tiles[x] = [];\n            for (let y = 0; y < size.height; y++) {\n                this.tiles[x][y] = initialTile;\n            }\n        }\n    }\n    get width() {\n        return this.tiles.length;\n    }\n    get height() {\n        return this.tiles[0].length;\n    }\n    get size() {\n        return { width: this.width, height: this.height };\n    }\n    /**\n     * Generates all {@link Vector points} contained by this area.\n     */\n    *points() {\n        for (let x = 0; x < this.width; x++) {\n            for (let y = 0; y < this.height; y++) {\n                yield new common_1.Vector(x, y);\n            }\n        }\n    }\n    /**\n     * Generates all {@link Tile tile}, {@link Vector point} tuples\n     * contained by this area.\n     */\n    *cells() {\n        for (let p of this.points()) {\n            yield [this.get(p), p];\n        }\n    }\n    /**\n     * Performs the given action for all tiles contained by\n     * this area.\n     */\n    forEach(consumer) {\n        for (let [t, p] of this.cells()) {\n            consumer(t, p);\n        }\n    }\n    get(point) {\n        return this.tiles[point.x][point.y];\n    }\n    set(point, tile) {\n        this.tiles[point.x][point.y] = tile;\n    }\n    contains(point) {\n        const x = point.x;\n        const y = point.y;\n        return x >= 0 && x < this.width && y >= 0 && y < this.height;\n    }\n    /**\n     * Returns all {@link Neighbours} of `point` for the given\n     * {@link Direction Directions}.\n     *\n     * @param point The point to get the nieghbours for\n     * @param directions The directions to select the neighbours.\n     *      Defaults to {@link Direction.all}.\n     */\n    neighbours(point, directions) {\n        let neighbours = {};\n        directions = directions || common_1.Direction.all();\n        for (let direction of directions) {\n            let newPoint = point.translate(direction);\n            if (this.contains(newPoint)) {\n                neighbours[direction.name] = this.get(newPoint);\n            }\n        }\n        return neighbours;\n    }\n    /**\n     * Set all points containing {@link Tile.Empty} to the given {@link Tile}.\n     */\n    fill(tile) {\n        for (let point of this.points()) {\n            if (this.get(point) === Tile.Empty) {\n                this.set(point, tile);\n            }\n        }\n    }\n}\nexports.Area = Area;\n/**\n * Performs flood filling on the given {@link Area} using `predicate`\n * to determine if a {@link Tile} is walkable.\n *\n * Results in an array of *sections*, where a section is a set of\n * {@link Vector points} where any point has a path to any other point.\n * This means, that no section has a path to another section.\n *\n * @param area The area to flood fill\n * @param predicate A function to determine if a tile is walkable\n *\n * @returns A two-dimensional array of {@link Vector points}, representing\n *      the sections of the area.\n */\nfunction floodFill(area, predicate) {\n    const sections = [];\n    const points = lodash_1.default.shuffle(Array.from(area.points()));\n    let start = points.find(p => predicate(area.get(p)));\n    while (start !== undefined) {\n        const section = [];\n        const stack = [start];\n        while (stack.length > 0) {\n            const point = stack.pop();\n            section.push(point);\n            for (let direction of common_1.Direction.straights()) {\n                const neighbour = point.translate(direction);\n                // TODO Can this be cleaned?\n                if (area.contains(neighbour) && predicate(area.get(neighbour)) && !section.some(p => p.x === neighbour.x && p.y === neighbour.y)) {\n                    stack.push(neighbour);\n                }\n            }\n        }\n        sections.push(section);\n        // TODO Can this be cleaned?\n        start = points.find(s => predicate(area.get(s)) && !sections.some(sec => sec.some(p => p.x === s.x && p.y === s.y)));\n    }\n    return sections;\n}\nexports.floodFill = floodFill;\n"]},"metadata":{},"sourceType":"script"}