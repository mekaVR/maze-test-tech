{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst area_1 = require(\"./domain/area\");\n/**\n * Create an object from the given data for the given {@link Field fields}.\n *\n * The data can be a string where the fields are separated by `,`: `\"value1, value2, field1=value3, field2=value4\"`\n * The values are mapped to the fields by position or by name, if provided.\n *\n * The data can also be a {@link Dict Dict<string>}, where the keys are the field names and the values are the field\n * values to be parsed.\n *\n * @param data The data to parse the object from\n * @param fields The fields to retrieve and parse the data entries\n *\n * @throws An error, if data is a string and positional arguments are used after keyword arguments.\n * @throws An error, if data is a string and an unknown field name is given.\n * @throws An error, if a field value can not be parsed.\n */\n// TODO Write tests\n\n\nfunction configFrom(data, fields) {\n  if (typeof data === \"string\") {\n    return configFromArgs(data, fields);\n  } else {\n    return configFromObject(data, fields);\n  }\n}\n\nexports.configFrom = configFrom;\n/**\n * Create an object from the given string for the given {@link Field fields}.\n *\n * Must be of the form `\"value1, value2, field1=value3, field2=value4\"`. The field separator, value separator and\n * ignore symbol can be provided. The values are mapped to the fields by position or by name, if provided.\n *\n * @param args The string to parse the object from\n * @param fields The fields to retrieve and parse the values\n * @param fieldsSeparator The symbol to split fields by\n * @param valueSeparator The symbol to split field names and values by\n * @param ignoreField The symbol to ignore positional arguments\n *\n * @throws An error, if positional arguments are used after keyword arguments.\n * @throws An error, if an unknown field name is given.\n * @throws An error, if a field value can not be parsed.\n */\n\nfunction configFromArgs(args, fields, fieldsSeparator = \",\", valueSeparator = \"=\", ignoreField = \"_\") {\n  const fieldsByName = {};\n  fields.forEach(f => fieldsByName[f.name] = f);\n  const configData = {};\n  const fieldArgs = args.split(fieldsSeparator);\n  let inKwargs = false;\n\n  for (let i = 0; i < fieldArgs.length; i++) {\n    const fieldArg = fieldArgs[i];\n    const isKwarg = fieldArg.includes(valueSeparator);\n\n    if (!isKwarg && inKwargs) {\n      throw new Error(\"Using positional arguments as after keyword arguments is forbidden\");\n    }\n\n    let field;\n    let value;\n\n    if (isKwarg) {\n      const fieldArgSplit = fieldArg.split(valueSeparator);\n      const fieldName = fieldArgSplit[0];\n\n      if (!(fieldName in fieldsByName)) {\n        throw new Error(`Unknown field '${fieldName}'`);\n      }\n\n      field = fieldsByName[fieldName];\n      value = fieldArgSplit[1];\n      inKwargs = true;\n    } else {\n      field = fields[i];\n      value = fieldArg;\n    }\n\n    if (value !== ignoreField) {\n      configData[field.name] = value;\n    }\n  }\n\n  return configFromObject(configData, fields);\n}\n\nexports.configFromArgs = configFromArgs;\n/**\n * Create an object from the given data for the given {@link Field fields}.\n *\n * The datas keys are the field names and the values are the field values to be parsed.\n *\n * @param data The data to parse the object from\n * @param fields The fields to retrieve and parse the data entries\n *\n * @throws An error, if a field value can not be parsed.\n */\n\nfunction configFromObject(data, fields) {\n  const fieldsByName = {};\n  fields.forEach(f => fieldsByName[f.name] = f);\n  const config = {};\n\n  for (let fieldName in data) {\n    const value = data[fieldName];\n    const field = fieldsByName[fieldName];\n\n    try {\n      config[field.name] = field.parser(value);\n    } catch (error) {\n      throw new Error(`Error parsing field ${field.name}: ${error.message}`);\n    }\n  }\n\n  return config;\n}\n\nexports.configFromObject = configFromObject;\n/**\n * Parse the given string as number and throw an error if the result is `NaN`.\n *\n * @throws An error, if the number can not be parsed.\n */\n\nfunction parseNumber(number) {\n  const value = Number(number);\n\n  if (isNaN(value)) {\n    throw new Error(`The given value '${number}' is not a number`);\n  }\n\n  return value;\n}\n\nexports.parseNumber = parseNumber;\n\nfunction capitalize(s) {\n  return s[0].toUpperCase() + s.substring(1);\n}\n\nexports.capitalize = capitalize;\n\nfunction decapitalize(s) {\n  return s[0].toLowerCase() + s.substring(1);\n}\n\nexports.decapitalize = decapitalize;\n/**\n * Utility method to create the string representation of an {@link Area}.\n */\n\nfunction areaToString(area) {\n  let row_strings = [];\n  row_strings.push(\"┏\" + \"━\".repeat(area.width * 2 + 1) + \"┓\");\n\n  for (let y = 0; y < area.height; y++) {\n    let tile_strings = [];\n\n    for (let x = 0; x < area.width; x++) {\n      const p = {\n        x: x,\n        y: y\n      };\n      tile_strings.push(_symbolFor(area.get(p)));\n    }\n\n    row_strings.push(\"┃ \" + tile_strings.join(\" \") + \" ┃\");\n  }\n\n  row_strings.push(\"┗\" + \"━\".repeat(area.width * 2 + 1) + \"┛\");\n  return row_strings.join(\"\\n\");\n}\n\nexports.areaToString = areaToString;\n\nfunction _symbolFor(tile) {\n  if (tile === area_1.Tile.Empty) {\n    return \"╳\";\n  } else if (tile.passable) {\n    return \" \";\n  } else {\n    return \"#\";\n  }\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/util.js"],"names":["Object","defineProperty","exports","value","area_1","require","configFrom","data","fields","configFromArgs","configFromObject","args","fieldsSeparator","valueSeparator","ignoreField","fieldsByName","forEach","f","name","configData","fieldArgs","split","inKwargs","i","length","fieldArg","isKwarg","includes","Error","field","fieldArgSplit","fieldName","config","parser","error","message","parseNumber","number","Number","isNaN","capitalize","s","toUpperCase","substring","decapitalize","toLowerCase","areaToString","area","row_strings","push","repeat","width","y","height","tile_strings","x","p","_symbolFor","get","join","tile","Tile","Empty","passable"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst area_1 = require(\"./domain/area\");\n/**\n * Create an object from the given data for the given {@link Field fields}.\n *\n * The data can be a string where the fields are separated by `,`: `\"value1, value2, field1=value3, field2=value4\"`\n * The values are mapped to the fields by position or by name, if provided.\n *\n * The data can also be a {@link Dict Dict<string>}, where the keys are the field names and the values are the field\n * values to be parsed.\n *\n * @param data The data to parse the object from\n * @param fields The fields to retrieve and parse the data entries\n *\n * @throws An error, if data is a string and positional arguments are used after keyword arguments.\n * @throws An error, if data is a string and an unknown field name is given.\n * @throws An error, if a field value can not be parsed.\n */\n// TODO Write tests\nfunction configFrom(data, fields) {\n    if (typeof data === \"string\") {\n        return configFromArgs(data, fields);\n    }\n    else {\n        return configFromObject(data, fields);\n    }\n}\nexports.configFrom = configFrom;\n/**\n * Create an object from the given string for the given {@link Field fields}.\n *\n * Must be of the form `\"value1, value2, field1=value3, field2=value4\"`. The field separator, value separator and\n * ignore symbol can be provided. The values are mapped to the fields by position or by name, if provided.\n *\n * @param args The string to parse the object from\n * @param fields The fields to retrieve and parse the values\n * @param fieldsSeparator The symbol to split fields by\n * @param valueSeparator The symbol to split field names and values by\n * @param ignoreField The symbol to ignore positional arguments\n *\n * @throws An error, if positional arguments are used after keyword arguments.\n * @throws An error, if an unknown field name is given.\n * @throws An error, if a field value can not be parsed.\n */\nfunction configFromArgs(args, fields, fieldsSeparator = \",\", valueSeparator = \"=\", ignoreField = \"_\") {\n    const fieldsByName = {};\n    fields.forEach(f => fieldsByName[f.name] = f);\n    const configData = {};\n    const fieldArgs = args.split(fieldsSeparator);\n    let inKwargs = false;\n    for (let i = 0; i < fieldArgs.length; i++) {\n        const fieldArg = fieldArgs[i];\n        const isKwarg = fieldArg.includes(valueSeparator);\n        if (!isKwarg && inKwargs) {\n            throw new Error(\"Using positional arguments as after keyword arguments is forbidden\");\n        }\n        let field;\n        let value;\n        if (isKwarg) {\n            const fieldArgSplit = fieldArg.split(valueSeparator);\n            const fieldName = fieldArgSplit[0];\n            if (!(fieldName in fieldsByName)) {\n                throw new Error(`Unknown field '${fieldName}'`);\n            }\n            field = fieldsByName[fieldName];\n            value = fieldArgSplit[1];\n            inKwargs = true;\n        }\n        else {\n            field = fields[i];\n            value = fieldArg;\n        }\n        if (value !== ignoreField) {\n            configData[field.name] = value;\n        }\n    }\n    return configFromObject(configData, fields);\n}\nexports.configFromArgs = configFromArgs;\n/**\n * Create an object from the given data for the given {@link Field fields}.\n *\n * The datas keys are the field names and the values are the field values to be parsed.\n *\n * @param data The data to parse the object from\n * @param fields The fields to retrieve and parse the data entries\n *\n * @throws An error, if a field value can not be parsed.\n */\nfunction configFromObject(data, fields) {\n    const fieldsByName = {};\n    fields.forEach(f => fieldsByName[f.name] = f);\n    const config = {};\n    for (let fieldName in data) {\n        const value = data[fieldName];\n        const field = fieldsByName[fieldName];\n        try {\n            config[field.name] = field.parser(value);\n        }\n        catch (error) {\n            throw new Error(`Error parsing field ${field.name}: ${error.message}`);\n        }\n    }\n    return config;\n}\nexports.configFromObject = configFromObject;\n/**\n * Parse the given string as number and throw an error if the result is `NaN`.\n *\n * @throws An error, if the number can not be parsed.\n */\nfunction parseNumber(number) {\n    const value = Number(number);\n    if (isNaN(value)) {\n        throw new Error(`The given value '${number}' is not a number`);\n    }\n    return value;\n}\nexports.parseNumber = parseNumber;\nfunction capitalize(s) {\n    return s[0].toUpperCase() + s.substring(1);\n}\nexports.capitalize = capitalize;\nfunction decapitalize(s) {\n    return s[0].toLowerCase() + s.substring(1);\n}\nexports.decapitalize = decapitalize;\n/**\n * Utility method to create the string representation of an {@link Area}.\n */\nfunction areaToString(area) {\n    let row_strings = [];\n    row_strings.push(\"┏\" + \"━\".repeat(area.width * 2 + 1) + \"┓\");\n    for (let y = 0; y < area.height; y++) {\n        let tile_strings = [];\n        for (let x = 0; x < area.width; x++) {\n            const p = { x: x, y: y };\n            tile_strings.push(_symbolFor(area.get(p)));\n        }\n        row_strings.push(\"┃ \" + tile_strings.join(\" \") + \" ┃\");\n    }\n    row_strings.push(\"┗\" + \"━\".repeat(area.width * 2 + 1) + \"┛\");\n    return row_strings.join(\"\\n\");\n}\nexports.areaToString = areaToString;\nfunction _symbolFor(tile) {\n    if (tile === area_1.Tile.Empty) {\n        return \"╳\";\n    }\n    else if (tile.passable) {\n        return \" \";\n    }\n    else {\n        return \"#\";\n    }\n}\n"]},"metadata":{},"sourceType":"script"}