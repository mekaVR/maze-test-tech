{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst area_1 = require(\"./domain/area\");\n/**\n * Set of functions to serialize and deserialize {@link Area}.\n */\n\n\nvar serialize;\n\n(function (serialize) {\n  /**\n   * Serializes the given {@link Area} {@link toBytes to bytes} and encodes\n   * the data as base64.\n   */\n  function toBase64(area) {\n    return Buffer.from(toBytes(area)).toString(\"base64\");\n  }\n\n  serialize.toBase64 = toBase64;\n  /**\n   * Serializes the given {@link Area} to bytes.\n   *\n   * The first 4 byte represent the width and height. Each following bit\n   * represents if the {@link Tile} is passable, going from `(0, 0)` to\n   * `(width - 1, height - 1)`.\n   */\n\n  function toBytes(area) {\n    return areaToBytes(area);\n  }\n\n  serialize.toBytes = toBytes;\n  /**\n   * Deserializes an {@link Area} from a base64 encoded string that was\n   * serialized with {@link toBase64}.\n   */\n\n  function fromBase64(data) {\n    return fromBytes(Buffer.from(data, \"base64\"));\n  }\n\n  serialize.fromBase64 = fromBase64;\n  /**\n   * Deserializes an {@link Area} from a byte array that was\n   * serialized with {@link toBytes}.\n   */\n\n  function fromBytes(bytes) {\n    return bytesToArea(bytes);\n  }\n\n  serialize.fromBytes = fromBytes;\n})(serialize = exports.serialize || (exports.serialize = {}));\n\nfunction areaToBytes(area) {\n  const bytes = new Uint8Array(4 + Math.ceil(area.width * area.height / 8));\n  bytes.set(int16ToBytes(area.width), 0);\n  bytes.set(int16ToBytes(area.height), 2);\n  let index = 4;\n  let bits = 0;\n  let byte = 0;\n\n  for (let y = 0; y < area.height; y++) {\n    for (let x = 0; x < area.width; x++) {\n      const tile = area.get({\n        x: x,\n        y: y\n      });\n\n      if (bits === 8) {\n        bytes[index] = byte;\n        index++;\n        bits = 0;\n        byte = 0;\n      }\n\n      byte = (byte << 1) + (tile.passable ? 1 : 0);\n      bits++;\n    }\n  }\n\n  byte = byte << 8 - bits;\n  bytes[index] = byte;\n  return bytes;\n}\n\nfunction bytesToArea(bytes) {\n  const area = new area_1.Area({\n    width: bytesToNumber(bytes.subarray(0, 2)),\n    height: bytesToNumber(bytes.subarray(2, 4))\n  });\n  const tileBytes = bytes.subarray(4);\n  let tileIndex = 0;\n\n  for (let i = 0; i < tileBytes.length && tileIndex < area.width * area.height; i++) {\n    const byte = tileBytes[i];\n\n    for (let b = 7; b >= 0 && tileIndex < area.width * area.height; b--) {\n      const bit = byte >> b & 1;\n      const tile = bit === 1 ? area_1.Tile.Floor : area_1.Tile.Wall;\n      const tilePoint = {\n        x: tileIndex % area.width,\n        y: Math.floor(tileIndex / area.width)\n      };\n      area.set(tilePoint, tile);\n      tileIndex++;\n    }\n  }\n\n  return area;\n}\n\nfunction int16ToBytes(value) {\n  const bytes = new Uint8Array([value >> 8 & 255, value & 255]);\n  return bytes;\n}\n\nfunction bytesToNumber(bytes) {\n  let value = bytes[0];\n\n  for (let i = 1; i < bytes.length; i++) {\n    value = value << 8;\n    value += bytes[i];\n  }\n\n  return value;\n}\n\nexports.default = serialize;","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/serialize.js"],"names":["Object","defineProperty","exports","value","area_1","require","serialize","toBase64","area","Buffer","from","toBytes","toString","areaToBytes","fromBase64","data","fromBytes","bytes","bytesToArea","Uint8Array","Math","ceil","width","height","set","int16ToBytes","index","bits","byte","y","x","tile","get","passable","Area","bytesToNumber","subarray","tileBytes","tileIndex","i","length","b","bit","Tile","Floor","Wall","tilePoint","floor","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst area_1 = require(\"./domain/area\");\n/**\n * Set of functions to serialize and deserialize {@link Area}.\n */\nvar serialize;\n(function (serialize) {\n    /**\n     * Serializes the given {@link Area} {@link toBytes to bytes} and encodes\n     * the data as base64.\n     */\n    function toBase64(area) {\n        return Buffer.from(toBytes(area)).toString(\"base64\");\n    }\n    serialize.toBase64 = toBase64;\n    /**\n     * Serializes the given {@link Area} to bytes.\n     *\n     * The first 4 byte represent the width and height. Each following bit\n     * represents if the {@link Tile} is passable, going from `(0, 0)` to\n     * `(width - 1, height - 1)`.\n     */\n    function toBytes(area) {\n        return areaToBytes(area);\n    }\n    serialize.toBytes = toBytes;\n    /**\n     * Deserializes an {@link Area} from a base64 encoded string that was\n     * serialized with {@link toBase64}.\n     */\n    function fromBase64(data) {\n        return fromBytes(Buffer.from(data, \"base64\"));\n    }\n    serialize.fromBase64 = fromBase64;\n    /**\n     * Deserializes an {@link Area} from a byte array that was\n     * serialized with {@link toBytes}.\n     */\n    function fromBytes(bytes) {\n        return bytesToArea(bytes);\n    }\n    serialize.fromBytes = fromBytes;\n})(serialize = exports.serialize || (exports.serialize = {}));\nfunction areaToBytes(area) {\n    const bytes = new Uint8Array(4 + Math.ceil((area.width * area.height) / 8));\n    bytes.set(int16ToBytes(area.width), 0);\n    bytes.set(int16ToBytes(area.height), 2);\n    let index = 4;\n    let bits = 0;\n    let byte = 0;\n    for (let y = 0; y < area.height; y++) {\n        for (let x = 0; x < area.width; x++) {\n            const tile = area.get({ x: x, y: y });\n            if (bits === 8) {\n                bytes[index] = byte;\n                index++;\n                bits = 0;\n                byte = 0;\n            }\n            byte = (byte << 1) + (tile.passable ? 1 : 0);\n            bits++;\n        }\n    }\n    byte = byte << (8 - bits);\n    bytes[index] = byte;\n    return bytes;\n}\nfunction bytesToArea(bytes) {\n    const area = new area_1.Area({\n        width: bytesToNumber(bytes.subarray(0, 2)),\n        height: bytesToNumber(bytes.subarray(2, 4))\n    });\n    const tileBytes = bytes.subarray(4);\n    let tileIndex = 0;\n    for (let i = 0; i < tileBytes.length && tileIndex < area.width * area.height; i++) {\n        const byte = tileBytes[i];\n        for (let b = 7; b >= 0 && tileIndex < area.width * area.height; b--) {\n            const bit = (byte >> b) & 1;\n            const tile = bit === 1 ? area_1.Tile.Floor : area_1.Tile.Wall;\n            const tilePoint = {\n                x: tileIndex % area.width,\n                y: Math.floor(tileIndex / area.width)\n            };\n            area.set(tilePoint, tile);\n            tileIndex++;\n        }\n    }\n    return area;\n}\nfunction int16ToBytes(value) {\n    const bytes = new Uint8Array([\n        (value >> 8) & 255,\n        value & 255\n    ]);\n    return bytes;\n}\nfunction bytesToNumber(bytes) {\n    let value = bytes[0];\n    for (let i = 1; i < bytes.length; i++) {\n        value = value << 8;\n        value += bytes[i];\n    }\n    return value;\n}\nexports.default = serialize;\n"]},"metadata":{},"sourceType":"script"}