{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst base_1 = require(\"./base\");\n\nconst area_1 = require(\"../domain/area\");\n\nconst common_1 = require(\"../domain/common\");\n\nconst solver_1 = require(\"../solver\");\n\nconst util_1 = require(\"../util\");\n\nconst BreakPassagesConfigFields = [{\n  name: \"amount\",\n  parser: util_1.parseNumber\n}, {\n  name: \"minimumShortcutDistance\",\n  parser: util_1.parseNumber\n}];\n/**\n * Replaces {@link BreakPassagesConfig.amount} random wall tiles that have\n * exactly 2 floor tiles as neighbours with floor tiles. The path length\n * between the 2 floor tiles must be greater equals than\n * {@link BreakPassagesConfig.minimumShortcutDistance}.\n *\n * It is possible that less wall tiles than the targeted amount are replaced,\n * if the minimum shortcut distance is too large.\n *\n * Example:\n * ```\n * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓\n * ┃           ┃    ┃           ┃\n * ┃   # # # # ┃    ┃   #   # # ┃\n * ┃   #       ┃ => ┃   #       ┃\n * ┃   # # #   ┃    ┃   # # #   ┃\n * ┃           ┃    ┃           ┃\n * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛\n * ```\n *\n * @returns The same, but modified area instance.\n */\n\nexports.BreakPassages = breakPassages;\nbase_1.registerModifier(\"BreakPassages\", exports.BreakPassages, BreakPassagesConfigFields);\n\nfunction breakPassages(area, config) {\n  let amount = config.amount || (area.width + area.height) / 2;\n  const minimumShortcutDistance = config.minimumShortcutDistance || Math.sqrt(area.width * area.height);\n  const candidates = lodash_1.default.shuffle(findCandidates(area));\n\n  while (amount >= 0 && candidates.length > 0) {\n    const candidate = candidates.pop();\n    const path = solver_1.findPath(area, candidate.neighbour1, candidate.neighbour2);\n\n    if (path === undefined || path.length >= minimumShortcutDistance) {\n      area.set(candidate.point, area_1.Tile.Floor);\n      amount--;\n    }\n  }\n\n  return area;\n}\n\nfunction findCandidates(area) {\n  const candidates = [];\n\n  for (let point of area.points()) {\n    if (!area.get(point).passable) {\n      let neighbours = area.neighbours(point, common_1.Direction.straights());\n      let passableCount = 0;\n\n      for (let directionName in neighbours) {\n        passableCount += neighbours[directionName].passable ? 1 : 0;\n      }\n\n      const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;\n      const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;\n      const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;\n      const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;\n\n      if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {\n        let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] : [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];\n        candidates.push(new PassageCandidate(point, passable1, passable2));\n      }\n    }\n  }\n\n  return candidates;\n}\n\nclass PassageCandidate {\n  constructor(point, neighbour1, neighbour2) {\n    this.point = point;\n    this.neighbour1 = neighbour1;\n    this.neighbour2 = neighbour2;\n  }\n\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/modifier/breakPassages.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","base_1","area_1","common_1","solver_1","util_1","BreakPassagesConfigFields","name","parser","parseNumber","BreakPassages","breakPassages","registerModifier","area","config","amount","width","height","minimumShortcutDistance","Math","sqrt","candidates","default","shuffle","findCandidates","length","candidate","pop","path","findPath","neighbour1","neighbour2","undefined","set","point","Tile","Floor","points","get","passable","neighbours","Direction","straights","passableCount","directionName","up","Up","Empty","down","Down","left","Left","right","Right","passable1","passable2","translate","push","PassageCandidate","constructor"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,QAAQ,GAAGP,eAAe,CAACQ,OAAO,CAAC,QAAD,CAAR,CAAhC;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,gBAAD,CAAtB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMM,yBAAyB,GAAG,CAC9B;AAAEC,EAAAA,IAAI,EAAE,QAAR;AAAkBC,EAAAA,MAAM,EAAEH,MAAM,CAACI;AAAjC,CAD8B,EAE9B;AAAEF,EAAAA,IAAI,EAAE,yBAAR;AAAmCC,EAAAA,MAAM,EAAEH,MAAM,CAACI;AAAlD,CAF8B,CAAlC;AAIA;;;;;;;;;;;;;;;;;;;;;;;AAsBAZ,OAAO,CAACa,aAAR,GAAwBC,aAAxB;AACAV,MAAM,CAACW,gBAAP,CAAwB,eAAxB,EAAyCf,OAAO,CAACa,aAAjD,EAAgEJ,yBAAhE;;AACA,SAASK,aAAT,CAAuBE,IAAvB,EAA6BC,MAA7B,EAAqC;AACjC,MAAIC,MAAM,GAAGD,MAAM,CAACC,MAAP,IAAiB,CAACF,IAAI,CAACG,KAAL,GAAaH,IAAI,CAACI,MAAnB,IAA6B,CAA3D;AACA,QAAMC,uBAAuB,GAAGJ,MAAM,CAACI,uBAAP,IAAkCC,IAAI,CAACC,IAAL,CAAUP,IAAI,CAACG,KAAL,GAAaH,IAAI,CAACI,MAA5B,CAAlE;AACA,QAAMI,UAAU,GAAGtB,QAAQ,CAACuB,OAAT,CAAiBC,OAAjB,CAAyBC,cAAc,CAACX,IAAD,CAAvC,CAAnB;;AACA,SAAOE,MAAM,IAAI,CAAV,IAAeM,UAAU,CAACI,MAAX,GAAoB,CAA1C,EAA6C;AACzC,UAAMC,SAAS,GAAGL,UAAU,CAACM,GAAX,EAAlB;AACA,UAAMC,IAAI,GAAGxB,QAAQ,CAACyB,QAAT,CAAkBhB,IAAlB,EAAwBa,SAAS,CAACI,UAAlC,EAA8CJ,SAAS,CAACK,UAAxD,CAAb;;AACA,QAAIH,IAAI,KAAKI,SAAT,IAAsBJ,IAAI,CAACH,MAAL,IAAeP,uBAAzC,EAAkE;AAC9DL,MAAAA,IAAI,CAACoB,GAAL,CAASP,SAAS,CAACQ,KAAnB,EAA0BhC,MAAM,CAACiC,IAAP,CAAYC,KAAtC;AACArB,MAAAA,MAAM;AACT;AACJ;;AACD,SAAOF,IAAP;AACH;;AACD,SAASW,cAAT,CAAwBX,IAAxB,EAA8B;AAC1B,QAAMQ,UAAU,GAAG,EAAnB;;AACA,OAAK,IAAIa,KAAT,IAAkBrB,IAAI,CAACwB,MAAL,EAAlB,EAAiC;AAC7B,QAAI,CAACxB,IAAI,CAACyB,GAAL,CAASJ,KAAT,EAAgBK,QAArB,EAA+B;AAC3B,UAAIC,UAAU,GAAG3B,IAAI,CAAC2B,UAAL,CAAgBN,KAAhB,EAAuB/B,QAAQ,CAACsC,SAAT,CAAmBC,SAAnB,EAAvB,CAAjB;AACA,UAAIC,aAAa,GAAG,CAApB;;AACA,WAAK,IAAIC,aAAT,IAA0BJ,UAA1B,EAAsC;AAClCG,QAAAA,aAAa,IAAIH,UAAU,CAACI,aAAD,CAAV,CAA0BL,QAA1B,GAAqC,CAArC,GAAyC,CAA1D;AACH;;AACD,YAAMM,EAAE,GAAGL,UAAU,CAACrC,QAAQ,CAACsC,SAAT,CAAmBK,EAAnB,CAAsBvC,IAAvB,CAAV,IAA0CL,MAAM,CAACiC,IAAP,CAAYY,KAAjE;AACA,YAAMC,IAAI,GAAGR,UAAU,CAACrC,QAAQ,CAACsC,SAAT,CAAmBQ,IAAnB,CAAwB1C,IAAzB,CAAV,IAA4CL,MAAM,CAACiC,IAAP,CAAYY,KAArE;AACA,YAAMG,IAAI,GAAGV,UAAU,CAACrC,QAAQ,CAACsC,SAAT,CAAmBU,IAAnB,CAAwB5C,IAAzB,CAAV,IAA4CL,MAAM,CAACiC,IAAP,CAAYY,KAArE;AACA,YAAMK,KAAK,GAAGZ,UAAU,CAACrC,QAAQ,CAACsC,SAAT,CAAmBY,KAAnB,CAAyB9C,IAA1B,CAAV,IAA6CL,MAAM,CAACiC,IAAP,CAAYY,KAAvE;;AACA,UAAIJ,aAAa,KAAK,CAAlB,IAAuB,CAACE,EAAE,CAACN,QAAH,IAAeS,IAAI,CAACT,QAArB,OAAoCW,IAAI,CAACX,QAAL,IAAiBa,KAAK,CAACb,QAA3D,CAA3B,EAAiG;AAC7F,YAAI,CAACe,SAAD,EAAYC,SAAZ,IAAyBV,EAAE,CAACN,QAAH,GAAc,CAACL,KAAK,CAACsB,SAAN,CAAgBrD,QAAQ,CAACsC,SAAT,CAAmBK,EAAnC,CAAD,EAAyCZ,KAAK,CAACsB,SAAN,CAAgBrD,QAAQ,CAACsC,SAAT,CAAmBQ,IAAnC,CAAzC,CAAd,GACzB,CAACf,KAAK,CAACsB,SAAN,CAAgBrD,QAAQ,CAACsC,SAAT,CAAmBU,IAAnC,CAAD,EAA2CjB,KAAK,CAACsB,SAAN,CAAgBrD,QAAQ,CAACsC,SAAT,CAAmBY,KAAnC,CAA3C,CADJ;AAEAhC,QAAAA,UAAU,CAACoC,IAAX,CAAgB,IAAIC,gBAAJ,CAAqBxB,KAArB,EAA4BoB,SAA5B,EAAuCC,SAAvC,CAAhB;AACH;AACJ;AACJ;;AACD,SAAOlC,UAAP;AACH;;AACD,MAAMqC,gBAAN,CAAuB;AACnBC,EAAAA,WAAW,CAACzB,KAAD,EAAQJ,UAAR,EAAoBC,UAApB,EAAgC;AACvC,SAAKG,KAAL,GAAaA,KAAb;AACA,SAAKJ,UAAL,GAAkBA,UAAlB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACH;;AALkB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst base_1 = require(\"./base\");\nconst area_1 = require(\"../domain/area\");\nconst common_1 = require(\"../domain/common\");\nconst solver_1 = require(\"../solver\");\nconst util_1 = require(\"../util\");\nconst BreakPassagesConfigFields = [\n    { name: \"amount\", parser: util_1.parseNumber },\n    { name: \"minimumShortcutDistance\", parser: util_1.parseNumber },\n];\n/**\n * Replaces {@link BreakPassagesConfig.amount} random wall tiles that have\n * exactly 2 floor tiles as neighbours with floor tiles. The path length\n * between the 2 floor tiles must be greater equals than\n * {@link BreakPassagesConfig.minimumShortcutDistance}.\n *\n * It is possible that less wall tiles than the targeted amount are replaced,\n * if the minimum shortcut distance is too large.\n *\n * Example:\n * ```\n * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓\n * ┃           ┃    ┃           ┃\n * ┃   # # # # ┃    ┃   #   # # ┃\n * ┃   #       ┃ => ┃   #       ┃\n * ┃   # # #   ┃    ┃   # # #   ┃\n * ┃           ┃    ┃           ┃\n * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛\n * ```\n *\n * @returns The same, but modified area instance.\n */\nexports.BreakPassages = breakPassages;\nbase_1.registerModifier(\"BreakPassages\", exports.BreakPassages, BreakPassagesConfigFields);\nfunction breakPassages(area, config) {\n    let amount = config.amount || (area.width + area.height) / 2;\n    const minimumShortcutDistance = config.minimumShortcutDistance || Math.sqrt(area.width * area.height);\n    const candidates = lodash_1.default.shuffle(findCandidates(area));\n    while (amount >= 0 && candidates.length > 0) {\n        const candidate = candidates.pop();\n        const path = solver_1.findPath(area, candidate.neighbour1, candidate.neighbour2);\n        if (path === undefined || path.length >= minimumShortcutDistance) {\n            area.set(candidate.point, area_1.Tile.Floor);\n            amount--;\n        }\n    }\n    return area;\n}\nfunction findCandidates(area) {\n    const candidates = [];\n    for (let point of area.points()) {\n        if (!area.get(point).passable) {\n            let neighbours = area.neighbours(point, common_1.Direction.straights());\n            let passableCount = 0;\n            for (let directionName in neighbours) {\n                passableCount += neighbours[directionName].passable ? 1 : 0;\n            }\n            const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;\n            const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;\n            const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;\n            const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;\n            if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {\n                let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] :\n                    [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];\n                candidates.push(new PassageCandidate(point, passable1, passable2));\n            }\n        }\n    }\n    return candidates;\n}\nclass PassageCandidate {\n    constructor(point, neighbour1, neighbour2) {\n        this.point = point;\n        this.neighbour1 = neighbour1;\n        this.neighbour2 = neighbour2;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}