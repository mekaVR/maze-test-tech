{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst base_1 = require(\"./base\");\n\nconst area_1 = require(\"../domain/area\");\n\nconst common_1 = require(\"../domain/common\");\n\nconst util_1 = require(\"../util\");\n\nconst RemoveDeadendsConfigFields = [{\n  name: \"deadendsToRemove\",\n  parser: util_1.parseNumber\n}];\nconst DeadendTile = area_1.Tile.impassable(\"Deadend\");\n/**\n * Removes a targeted amount ({@link RemoveDeadendsConfig.deadendsToRemove see config})\n * of deadends (tiles with a single walkable neighbour), replacing them with wall tiles.\n *\n * Beware that using this modifier on an unmodified area generated by the built-in\n * algorithms will fill it completely with wall tiles, since all tiles will become\n * deadends.\n *\n * It is possible that less than the targeted amount of deadends removed, if no further\n * deadends exist.\n *\n * Example (removing 30% of the deadends):\n * ```\n * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓\n * ┃       #   ┃    ┃ # # # #   ┃\n * ┃ # #   #   ┃    ┃ # # # #   ┃\n * ┃   #       ┃ => ┃   #       ┃\n * ┃   #   #   ┃    ┃   #   # # ┃\n * ┃       #   ┃    ┃       # # ┃\n * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛\n * ```\n */\n\nexports.RemoveDeadends = removeDeadends;\nbase_1.registerModifier(\"RemoveDeadends\", exports.RemoveDeadends, RemoveDeadendsConfigFields);\n\nfunction removeDeadends(area, config) {\n  const collectedDeadends = [];\n  const currentDeadends = lodash_1.default.shuffle(findDeadends(area));\n\n  while (currentDeadends.length > 0) {\n    const deadend = currentDeadends.pop();\n    area.set(deadend.point, DeadendTile);\n    collectedDeadends.push(deadend.point);\n\n    if (deadend.passableDirection !== undefined) {\n      const nextDeadend = asDeadend(area, deadend.point.translate(deadend.passableDirection));\n\n      if (nextDeadend !== undefined) {\n        currentDeadends.unshift(nextDeadend);\n      }\n    }\n  }\n\n  let deadendsToRemove = config.deadendsToRemove || 1;\n\n  if (deadendsToRemove <= 1) {\n    deadendsToRemove = deadendsToRemove * collectedDeadends.length;\n  }\n\n  for (let deadend of collectedDeadends) {\n    const tile = deadendsToRemove > 0 ? area_1.Tile.Wall : area_1.Tile.Floor;\n    area.set(deadend, tile);\n    deadendsToRemove--;\n  }\n\n  return area;\n}\n\nfunction findDeadends(area) {\n  const deadends = [];\n\n  for (let point of area.points()) {\n    if (area.get(point).passable) {\n      const deadend = asDeadend(area, point);\n\n      if (deadend !== undefined) {\n        deadends.push(deadend);\n      }\n    }\n  }\n\n  return deadends;\n}\n\nfunction asDeadend(area, point) {\n  const neighbours = area.neighbours(point, common_1.Direction.straights());\n  let impassableCount = 0;\n  let passableDirection = undefined;\n\n  for (let direction of common_1.Direction.straights()) {\n    const neighbour = neighbours[direction.name];\n\n    if (neighbour === undefined || !neighbour.passable) {\n      impassableCount++;\n    } else {\n      passableDirection = direction;\n    }\n  }\n\n  return impassableCount >= 3 ? {\n    point: point,\n    passableDirection: passableDirection\n  } : undefined;\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/modifier/removeDeadends.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","base_1","area_1","common_1","util_1","RemoveDeadendsConfigFields","name","parser","parseNumber","DeadendTile","Tile","impassable","RemoveDeadends","removeDeadends","registerModifier","area","config","collectedDeadends","currentDeadends","default","shuffle","findDeadends","length","deadend","pop","set","point","push","passableDirection","undefined","nextDeadend","asDeadend","translate","unshift","deadendsToRemove","tile","Wall","Floor","deadends","points","get","passable","neighbours","Direction","straights","impassableCount","direction","neighbour"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst base_1 = require(\"./base\");\nconst area_1 = require(\"../domain/area\");\nconst common_1 = require(\"../domain/common\");\nconst util_1 = require(\"../util\");\nconst RemoveDeadendsConfigFields = [\n    { name: \"deadendsToRemove\", parser: util_1.parseNumber }\n];\nconst DeadendTile = area_1.Tile.impassable(\"Deadend\");\n/**\n * Removes a targeted amount ({@link RemoveDeadendsConfig.deadendsToRemove see config})\n * of deadends (tiles with a single walkable neighbour), replacing them with wall tiles.\n *\n * Beware that using this modifier on an unmodified area generated by the built-in\n * algorithms will fill it completely with wall tiles, since all tiles will become\n * deadends.\n *\n * It is possible that less than the targeted amount of deadends removed, if no further\n * deadends exist.\n *\n * Example (removing 30% of the deadends):\n * ```\n * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓\n * ┃       #   ┃    ┃ # # # #   ┃\n * ┃ # #   #   ┃    ┃ # # # #   ┃\n * ┃   #       ┃ => ┃   #       ┃\n * ┃   #   #   ┃    ┃   #   # # ┃\n * ┃       #   ┃    ┃       # # ┃\n * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛\n * ```\n */\nexports.RemoveDeadends = removeDeadends;\nbase_1.registerModifier(\"RemoveDeadends\", exports.RemoveDeadends, RemoveDeadendsConfigFields);\nfunction removeDeadends(area, config) {\n    const collectedDeadends = [];\n    const currentDeadends = lodash_1.default.shuffle(findDeadends(area));\n    while (currentDeadends.length > 0) {\n        const deadend = currentDeadends.pop();\n        area.set(deadend.point, DeadendTile);\n        collectedDeadends.push(deadend.point);\n        if (deadend.passableDirection !== undefined) {\n            const nextDeadend = asDeadend(area, deadend.point.translate(deadend.passableDirection));\n            if (nextDeadend !== undefined) {\n                currentDeadends.unshift(nextDeadend);\n            }\n        }\n    }\n    let deadendsToRemove = config.deadendsToRemove || 1;\n    if (deadendsToRemove <= 1) {\n        deadendsToRemove = deadendsToRemove * collectedDeadends.length;\n    }\n    for (let deadend of collectedDeadends) {\n        const tile = deadendsToRemove > 0 ? area_1.Tile.Wall : area_1.Tile.Floor;\n        area.set(deadend, tile);\n        deadendsToRemove--;\n    }\n    return area;\n}\nfunction findDeadends(area) {\n    const deadends = [];\n    for (let point of area.points()) {\n        if (area.get(point).passable) {\n            const deadend = asDeadend(area, point);\n            if (deadend !== undefined) {\n                deadends.push(deadend);\n            }\n        }\n    }\n    return deadends;\n}\nfunction asDeadend(area, point) {\n    const neighbours = area.neighbours(point, common_1.Direction.straights());\n    let impassableCount = 0;\n    let passableDirection = undefined;\n    for (let direction of common_1.Direction.straights()) {\n        const neighbour = neighbours[direction.name];\n        if (neighbour === undefined || !neighbour.passable) {\n            impassableCount++;\n        }\n        else {\n            passableDirection = direction;\n        }\n    }\n    return impassableCount >= 3 ? { point: point, passableDirection: passableDirection } : undefined;\n}\n"]},"metadata":{},"sourceType":"script"}