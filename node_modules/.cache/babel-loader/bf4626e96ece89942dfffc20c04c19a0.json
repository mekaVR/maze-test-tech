{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst util_1 = require(\"../util\");\n/** Utility functions for {@link Size} */\n\n\nvar Size;\n\n(function (Size) {\n  /** Format `size` as a string: `<width>x<height>` */\n  function stringify(size) {\n    return `${size.width}x${size.height}`;\n  }\n\n  Size.stringify = stringify;\n  /**\n   * Creates a new {@link Size} object from the given data.\n   *\n   * `data` must be an object with attribute `size` or\n   * `width` **and** `height`. The value for `size` can\n   * be a string parseable by {@link fromString} or another\n   * object with `width` and `height` attributes.\n   *\n   * @throws An error, if the `data` has no size information.\n   */\n\n  function fromObject(data) {\n    if (data.size !== undefined) {\n      if (typeof data.size === \"string\") {\n        return Size.fromString(data.size);\n      } else {\n        return {\n          width: data.size.width,\n          height: data.size.height\n        };\n      }\n    } else if (data.width !== undefined && data.height !== undefined) {\n      return {\n        width: data.width,\n        height: data.height\n      };\n    } else {\n      throw new Error(\"No size information could be found\");\n    }\n  }\n\n  Size.fromObject = fromObject;\n  /**\n   * Creates a new {@link Size} object from the given string.\n   *\n   * The string must have the format `<width>x<height>`, where\n   * width and height are valid numbers.\n   *\n   * @throws An error, if `value` does not match the format\n   */\n\n  function fromString(value) {\n    let parts = value.split(\"x\");\n\n    if (parts.length != 2) {\n      throw new Error(`The given value '${value}' does not match the required format WIDTHxHEIGHT`);\n    }\n\n    try {\n      return {\n        width: util_1.parseNumber(parts[0]),\n        height: util_1.parseNumber(parts[1])\n      };\n    } catch (error) {\n      throw new Error(`The values of the given size '${value}' can not be parsed as number`);\n    }\n  }\n\n  Size.fromString = fromString;\n})(Size = exports.Size || (exports.Size = {}));\n/**\n * Extension class for {@link Point} providing additional\n * utility methods.\n */\n\n\nclass Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /** Creates a new vector from the given {@link Point} */\n\n\n  static from(point) {\n    return new Vector(point.x, point.y);\n  }\n  /**\n   * Creates a random vector with `0 <= x < size.width` and\n   * `0 <= y < size.height` that matches the given predicate.\n   *\n   * May result in an infinite loop, if `predicate` never returns\n   * `true`.\n   *\n   * @param size The upper bound of the resulting vector\n   * @param predicate Function that checks if a random point is valid.\n   */\n\n\n  static random(size, predicate) {\n    let point;\n\n    do {\n      point = new Vector(lodash_1.default.random(size.width - 1), lodash_1.default.random(size.height - 1));\n    } while (predicate !== undefined && !predicate(point));\n\n    return point;\n  }\n  /**\n   * Translates this vector by the given delta x and delta y\n   * multiplied by `times`, creating a new vector instance.\n   *\n   * If `by` doesn't have `dx`/`dy` 0 is used.\n   *\n   * @param by The amount to move by\n   * @param times Factor used to multiply `by` by\n   *\n   * @returns A new vector instance translated by `by * times`\n   */\n\n\n  translate(by, times = 1) {\n    return new Vector(this.x + (by.dx || 0) * times, this.y + (by.dy || 0) * times);\n  }\n  /** Calculated the euclidean distance to the given {@link Point}. */\n\n\n  distance(other) {\n    const dx = other.x - this.x;\n    const dy = other.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   * Checks if `x` and `y` of the given {@link Point} are strictly\n   * equal to this vector.\n   */\n\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n}\n\nexports.Vector = Vector;\n\nclass Rectangle {\n  /**\n   * @param topLeft Top left coordinates of the rectangle\n   * @param size Size of the rectangle\n   */\n  constructor(topLeft, size) {\n    this.size = size;\n    this.topLeft = new Vector(topLeft.x, topLeft.y);\n    this.topRight = new Vector(topLeft.x + size.width - 1, topLeft.y);\n    this.bottomLeft = new Vector(topLeft.x, topLeft.y + size.height - 1);\n    this.bottomRight = new Vector(topLeft.x + size.width - 1, topLeft.y + size.height - 1);\n  }\n\n  get width() {\n    return this.size.width;\n  }\n\n  get height() {\n    return this.size.height;\n  }\n\n  intersect(other) {\n    return this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x && this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y;\n  }\n  /**\n   * Generates all {@link Vector points} contained by this rectangle.\n   */\n\n\n  *points() {\n    for (let x = this.topLeft.x; x <= this.bottomRight.x; x++) {\n      for (let y = this.topLeft.y; y <= this.bottomRight.y; y++) {\n        yield new Vector(x, y);\n      }\n    }\n  }\n\n  forEach(consumer) {\n    for (let p of this.points()) {\n      consumer(p);\n    }\n  }\n\n}\n\nexports.Rectangle = Rectangle;\n/** Utility class for the possible directions */\n\nclass Direction {\n  constructor(name, dx, dy) {\n    this.name = name;\n    this.dx = dx;\n    this.dy = dy;\n  }\n  /**\n   * @returns `true`, if the direction is strictly horizontal\n   */\n\n\n  isHorizontal() {\n    if (this === Direction.Left || this === Direction.Right) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @returns `true`, if the direction is strictly vertical\n   */\n\n\n  isVertical() {\n    if (this === Direction.Up || this === Direction.Down) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @returns `true`, if the direction is horizontal or vertical\n   */\n\n\n  isStraight() {\n    return this.isHorizontal() || this.isVertical();\n  }\n  /**\n   * @returns `true`, if the direction is diagonal\n   */\n\n\n  isDiagonal() {\n    return Direction.diagonals().includes(this);\n  }\n  /**\n   * @returns The opposite if this direction.\n   */\n\n\n  opposite() {\n    let index = Direction.all().indexOf(this);\n    return Direction.all()[(index + 4) % 8];\n  }\n  /**\n   * @returns The direction for the given name\n   *\n   * @throws An error, if no direction for the name could be found\n   */\n\n\n  static forName(name) {\n    let direction = Direction.values().find(d => d.name === name);\n\n    if (direction === undefined) {\n      throw new Error(`No direction available for name ${name}`);\n    }\n\n    return direction;\n  }\n  /**\n   * @returns All directions, including the `None` direction\n   */\n\n\n  static values() {\n    return Direction._values;\n  }\n  /**\n   * @returns All actual directions (without the `None` direction)\n   */\n\n\n  static all() {\n    return Direction._all;\n  }\n  /**\n   * @returns All straight directions\n   */\n\n\n  static straights() {\n    return Direction._straights;\n  }\n  /**\n   * @returns All diagonal directions\n   */\n\n\n  static diagonals() {\n    return Direction._diagonals;\n  }\n\n}\n\nexports.Direction = Direction;\nDirection.None = new Direction(\"None\", 0, 0);\nDirection.Up = new Direction(\"Up\", 0, -1);\nDirection.UpRight = new Direction(\"UpRight\", 1, -1);\nDirection.Right = new Direction(\"Right\", 1, 0);\nDirection.DownRight = new Direction(\"DownRight\", 1, 1);\nDirection.Down = new Direction(\"Down\", 0, 1);\nDirection.DownLeft = new Direction(\"DownLeft\", -1, 1);\nDirection.Left = new Direction(\"Left\", -1, 0);\nDirection.UpLeft = new Direction(\"UpLeft\", -1, 1);\nDirection._values = [Direction.None, Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];\nDirection._all = [Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight, Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft];\nDirection._straights = [Direction.Up, Direction.Right, Direction.Down, Direction.Left];\nDirection._diagonals = [Direction.UpRight, Direction.DownRight, Direction.DownLeft, Direction.UpLeft];","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/domain/common.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","util_1","Size","stringify","size","width","height","fromObject","data","undefined","fromString","Error","parts","split","length","parseNumber","error","Vector","constructor","x","y","from","point","random","predicate","default","translate","by","times","dx","dy","distance","other","Math","sqrt","equals","Rectangle","topLeft","topRight","bottomLeft","bottomRight","intersect","points","forEach","consumer","p","Direction","name","isHorizontal","Left","Right","isVertical","Up","Down","isStraight","isDiagonal","diagonals","includes","opposite","index","all","indexOf","forName","direction","values","find","d","_values","_all","straights","_straights","_diagonals","None","UpRight","DownRight","DownLeft","UpLeft"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst util_1 = require(\"../util\");\n/** Utility functions for {@link Size} */\nvar Size;\n(function (Size) {\n    /** Format `size` as a string: `<width>x<height>` */\n    function stringify(size) {\n        return `${size.width}x${size.height}`;\n    }\n    Size.stringify = stringify;\n    /**\n     * Creates a new {@link Size} object from the given data.\n     *\n     * `data` must be an object with attribute `size` or\n     * `width` **and** `height`. The value for `size` can\n     * be a string parseable by {@link fromString} or another\n     * object with `width` and `height` attributes.\n     *\n     * @throws An error, if the `data` has no size information.\n     */\n    function fromObject(data) {\n        if (data.size !== undefined) {\n            if (typeof data.size === \"string\") {\n                return Size.fromString(data.size);\n            }\n            else {\n                return { width: data.size.width, height: data.size.height };\n            }\n        }\n        else if (data.width !== undefined && data.height !== undefined) {\n            return { width: data.width, height: data.height };\n        }\n        else {\n            throw new Error(\"No size information could be found\");\n        }\n    }\n    Size.fromObject = fromObject;\n    /**\n     * Creates a new {@link Size} object from the given string.\n     *\n     * The string must have the format `<width>x<height>`, where\n     * width and height are valid numbers.\n     *\n     * @throws An error, if `value` does not match the format\n     */\n    function fromString(value) {\n        let parts = value.split(\"x\");\n        if (parts.length != 2) {\n            throw new Error(`The given value '${value}' does not match the required format WIDTHxHEIGHT`);\n        }\n        try {\n            return { width: util_1.parseNumber(parts[0]), height: util_1.parseNumber(parts[1]) };\n        }\n        catch (error) {\n            throw new Error(`The values of the given size '${value}' can not be parsed as number`);\n        }\n    }\n    Size.fromString = fromString;\n})(Size = exports.Size || (exports.Size = {}));\n/**\n * Extension class for {@link Point} providing additional\n * utility methods.\n */\nclass Vector {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /** Creates a new vector from the given {@link Point} */\n    static from(point) {\n        return new Vector(point.x, point.y);\n    }\n    /**\n     * Creates a random vector with `0 <= x < size.width` and\n     * `0 <= y < size.height` that matches the given predicate.\n     *\n     * May result in an infinite loop, if `predicate` never returns\n     * `true`.\n     *\n     * @param size The upper bound of the resulting vector\n     * @param predicate Function that checks if a random point is valid.\n     */\n    static random(size, predicate) {\n        let point;\n        do {\n            point = new Vector(lodash_1.default.random(size.width - 1), lodash_1.default.random(size.height - 1));\n        } while (predicate !== undefined && !predicate(point));\n        return point;\n    }\n    /**\n     * Translates this vector by the given delta x and delta y\n     * multiplied by `times`, creating a new vector instance.\n     *\n     * If `by` doesn't have `dx`/`dy` 0 is used.\n     *\n     * @param by The amount to move by\n     * @param times Factor used to multiply `by` by\n     *\n     * @returns A new vector instance translated by `by * times`\n     */\n    translate(by, times = 1) {\n        return new Vector(this.x + (by.dx || 0) * times, this.y + (by.dy || 0) * times);\n    }\n    /** Calculated the euclidean distance to the given {@link Point}. */\n    distance(other) {\n        const dx = other.x - this.x;\n        const dy = other.y - this.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Checks if `x` and `y` of the given {@link Point} are strictly\n     * equal to this vector.\n     */\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n}\nexports.Vector = Vector;\nclass Rectangle {\n    /**\n     * @param topLeft Top left coordinates of the rectangle\n     * @param size Size of the rectangle\n     */\n    constructor(topLeft, size) {\n        this.size = size;\n        this.topLeft = new Vector(topLeft.x, topLeft.y);\n        this.topRight = new Vector(topLeft.x + size.width - 1, topLeft.y);\n        this.bottomLeft = new Vector(topLeft.x, topLeft.y + size.height - 1);\n        this.bottomRight = new Vector(topLeft.x + size.width - 1, topLeft.y + size.height - 1);\n    }\n    get width() {\n        return this.size.width;\n    }\n    get height() {\n        return this.size.height;\n    }\n    intersect(other) {\n        return this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x\n            && this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y;\n    }\n    /**\n     * Generates all {@link Vector points} contained by this rectangle.\n     */\n    *points() {\n        for (let x = this.topLeft.x; x <= this.bottomRight.x; x++) {\n            for (let y = this.topLeft.y; y <= this.bottomRight.y; y++) {\n                yield new Vector(x, y);\n            }\n        }\n    }\n    forEach(consumer) {\n        for (let p of this.points()) {\n            consumer(p);\n        }\n    }\n}\nexports.Rectangle = Rectangle;\n/** Utility class for the possible directions */\nclass Direction {\n    constructor(name, dx, dy) {\n        this.name = name;\n        this.dx = dx;\n        this.dy = dy;\n    }\n    /**\n     * @returns `true`, if the direction is strictly horizontal\n     */\n    isHorizontal() {\n        if (this === Direction.Left || this === Direction.Right) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * @returns `true`, if the direction is strictly vertical\n     */\n    isVertical() {\n        if (this === Direction.Up || this === Direction.Down) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * @returns `true`, if the direction is horizontal or vertical\n     */\n    isStraight() {\n        return this.isHorizontal() || this.isVertical();\n    }\n    /**\n     * @returns `true`, if the direction is diagonal\n     */\n    isDiagonal() {\n        return Direction.diagonals().includes(this);\n    }\n    /**\n     * @returns The opposite if this direction.\n     */\n    opposite() {\n        let index = Direction.all().indexOf(this);\n        return Direction.all()[(index + 4) % 8];\n    }\n    /**\n     * @returns The direction for the given name\n     *\n     * @throws An error, if no direction for the name could be found\n     */\n    static forName(name) {\n        let direction = Direction.values().find(d => d.name === name);\n        if (direction === undefined) {\n            throw new Error(`No direction available for name ${name}`);\n        }\n        return direction;\n    }\n    /**\n     * @returns All directions, including the `None` direction\n     */\n    static values() {\n        return Direction._values;\n    }\n    /**\n     * @returns All actual directions (without the `None` direction)\n     */\n    static all() {\n        return Direction._all;\n    }\n    /**\n     * @returns All straight directions\n     */\n    static straights() {\n        return Direction._straights;\n    }\n    /**\n     * @returns All diagonal directions\n     */\n    static diagonals() {\n        return Direction._diagonals;\n    }\n}\nexports.Direction = Direction;\nDirection.None = new Direction(\"None\", 0, 0);\nDirection.Up = new Direction(\"Up\", 0, -1);\nDirection.UpRight = new Direction(\"UpRight\", 1, -1);\nDirection.Right = new Direction(\"Right\", 1, 0);\nDirection.DownRight = new Direction(\"DownRight\", 1, 1);\nDirection.Down = new Direction(\"Down\", 0, 1);\nDirection.DownLeft = new Direction(\"DownLeft\", -1, 1);\nDirection.Left = new Direction(\"Left\", -1, 0);\nDirection.UpLeft = new Direction(\"UpLeft\", -1, 1);\nDirection._values = [\n    Direction.None,\n    Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight,\n    Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft\n];\nDirection._all = [\n    Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight,\n    Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft\n];\nDirection._straights = [\n    Direction.Up, Direction.Right, Direction.Down, Direction.Left\n];\nDirection._diagonals = [\n    Direction.UpRight, Direction.DownRight, Direction.DownLeft, Direction.UpLeft\n];\n"]},"metadata":{},"sourceType":"script"}