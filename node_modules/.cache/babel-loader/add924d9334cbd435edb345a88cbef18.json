{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst base_1 = require(\"./base\");\n\nconst area_1 = require(\"../domain/area\");\n\nconst common_1 = require(\"../domain/common\");\n\nconst simple_1 = require(\"./simple\");\n\nconst util_1 = require(\"../util\");\n\nconst defaultMinSizeFactor = 0.04;\nconst defaultMaxSizeFactor = 0.1;\nconst minMinRoomSize = 3;\nconst minMaxRoomSize = 5;\nconst defaultRoomPlacementAttemptsFactor = 0.5;\nconst maximumDefaultRoomPlacementAttempts = 1000;\nconst NystromConfigFields = [{\n  name: \"roomPlacementAttempts\",\n  parser: util_1.parseNumber\n}, {\n  name: \"minRoomSize\",\n  parser: common_1.Size.fromString\n}, {\n  name: \"maxRoomSize\",\n  parser: common_1.Size.fromString\n}];\n/**\n * Area generation algorithm based on this\n * {@link http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/ article}\n * by Bob Nystrom.\n *\n * Generates dense, perfect areas with rooms. Uses {@link RecursiveBacktracker} to\n * fill the space between rooms. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃       #       #               ┃\n * ┃       #       # #   # # # #   ┃\n * ┃                           #   ┃\n * ┃ # # # #       #           #   ┃\n * ┃               #           #   ┃\n * ┃   # # # # # # #           #   ┃\n * ┃   #       #   #           #   ┃\n * ┃   #       #   # # # # # # #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # #   # #       #   #   # # ┃\n * ┃                   #           ┃\n * ┃ # #   #   # # #   # # # # #   ┃\n * ┃       #       #   #           ┃\n * ┃   # # #       #   #           ┃\n * ┃       #       #   #           ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n *\n * @see {@link NystromConfig} for the default configuration\n * @see {@link BreakPassages} to add cycles\n * @see {@link RemoveDeadends} to remove all or a percentage of deadends\n */\n\nexports.Nystrom = nystrom;\nbase_1.registerGenerator(\"Nystrom\", exports.Nystrom, NystromConfigFields);\n\nfunction nystrom(c) {\n  let config = new _NystromConfig(c);\n  const area = new area_1.Area(config.size, area_1.Tile.Wall);\n\n  for (let i = 0; i < config.roomPlacementAttempts; i++) {\n    tryToAddRoom(config, area);\n  }\n\n  carvePassages(area);\n  connectSections(area);\n  return area;\n}\n\nfunction tryToAddRoom(config, area) {\n  const room = randomRoom(config);\n\n  for (let point of room.points()) {\n    if (!area.contains(point) || area.get(point).passable) {\n      return;\n    }\n  }\n\n  room.forEach(p => area.set(p, area_1.Tile.Floor));\n}\n\nfunction randomRoom(config) {\n  const start = common_1.Vector.random(config.size, p => p.x % 2 === 0 && p.y % 2 === 0);\n  let size;\n\n  do {\n    // TODO Don't force odd room sizes, instead configure a minimum room distance\n    size = {\n      width: lodash_1.default.random(config.minRoomSize.width, config.maxRoomSize.width),\n      height: lodash_1.default.random(config.minRoomSize.height, config.maxRoomSize.height)\n    };\n  } while (size.width % 2 === 0 || size.height % 2 === 0);\n\n  return new common_1.Rectangle(start, size);\n}\n\nfunction carvePassages(area) {\n  let start;\n\n  do {\n    start = undefined;\n\n    for (let point of area.points()) {\n      if (!area.get(point).passable && point.x % 2 === 0 && point.y % 2 === 0) {\n        start = point;\n        break;\n      }\n    }\n\n    if (start !== undefined) {\n      simple_1.recursiveBacktrack(area, start);\n    }\n  } while (start !== undefined);\n}\n\nfunction connectSections(area) {\n  const sections = area_1.floodFill(area, t => t.passable);\n\n  while (sections.length > 1) {\n    const link = lodash_1.default.sample(findSectionLinks(area, sections));\n    area.set(link.point, area_1.Tile.Floor);\n    sections[link.section1].push(link.point, ...sections[link.section2]);\n    sections.splice(link.section2, 1);\n  }\n}\n\nfunction findSectionLinks(area, sections) {\n  const sectionIndex = point => {\n    for (let index = 0; index < sections.length; index++) {\n      const section = sections[index];\n\n      if (section.some(p => p.x === point.x && p.y === point.y)) {\n        return index;\n      }\n    }\n\n    return undefined;\n  };\n\n  const links = [];\n\n  for (let point of area.points()) {\n    if (!area.get(point).passable) {\n      let neighbours = area.neighbours(point, common_1.Direction.straights());\n      let passableCount = 0;\n\n      for (let directionName in neighbours) {\n        passableCount += neighbours[directionName].passable ? 1 : 0;\n      }\n\n      const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;\n      const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;\n      const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;\n      const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;\n\n      if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {\n        let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] : [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];\n        let section1 = sectionIndex(passable1);\n        let section2 = sectionIndex(passable2);\n\n        if (section1 !== section2) {\n          links.push({\n            point: point,\n            section1: section1,\n            section2: section2\n          });\n        }\n      }\n    }\n  }\n\n  return links;\n}\n\nclass _NystromConfig {\n  constructor(config) {\n    this.size = config.size;\n    this.minRoomSize = config.minRoomSize || this.defaultMinRoomSize();\n    this.maxRoomSize = config.maxRoomSize || this.defaultMaxRoomSize();\n    this.roomPlacementAttempts = config.roomPlacementAttempts || Math.min(config.size.width * config.size.height * defaultRoomPlacementAttemptsFactor, maximumDefaultRoomPlacementAttempts);\n  }\n\n  defaultMinRoomSize() {\n    const baseSize = Math.round((this.size.width + this.size.height) * 0.5);\n    const width = baseSize * defaultMinSizeFactor;\n    const height = baseSize * defaultMinSizeFactor;\n    return {\n      width: Math.max(minMinRoomSize, width),\n      height: Math.max(minMinRoomSize, height)\n    };\n  }\n\n  defaultMaxRoomSize() {\n    const baseSize = Math.round((this.size.width + this.size.height) * 0.5);\n    const width = baseSize * defaultMaxSizeFactor;\n    const height = baseSize * defaultMaxSizeFactor;\n    return {\n      width: Math.max(minMaxRoomSize, width),\n      height: Math.max(minMaxRoomSize, height)\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/meka/Sites/frontend-tech-test/node_modules/amazer/dist/generator/nystrom.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","base_1","area_1","common_1","simple_1","util_1","defaultMinSizeFactor","defaultMaxSizeFactor","minMinRoomSize","minMaxRoomSize","defaultRoomPlacementAttemptsFactor","maximumDefaultRoomPlacementAttempts","NystromConfigFields","name","parser","parseNumber","Size","fromString","Nystrom","nystrom","registerGenerator","c","config","_NystromConfig","area","Area","size","Tile","Wall","i","roomPlacementAttempts","tryToAddRoom","carvePassages","connectSections","room","randomRoom","point","points","contains","get","passable","forEach","p","set","Floor","start","Vector","random","x","y","width","default","minRoomSize","maxRoomSize","height","Rectangle","undefined","recursiveBacktrack","sections","floodFill","t","length","link","sample","findSectionLinks","section1","push","section2","splice","sectionIndex","index","section","some","links","neighbours","Direction","straights","passableCount","directionName","up","Up","Empty","down","Down","left","Left","right","Right","passable1","passable2","translate","constructor","defaultMinRoomSize","defaultMaxRoomSize","Math","min","baseSize","round","max"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst base_1 = require(\"./base\");\nconst area_1 = require(\"../domain/area\");\nconst common_1 = require(\"../domain/common\");\nconst simple_1 = require(\"./simple\");\nconst util_1 = require(\"../util\");\nconst defaultMinSizeFactor = 0.04;\nconst defaultMaxSizeFactor = 0.1;\nconst minMinRoomSize = 3;\nconst minMaxRoomSize = 5;\nconst defaultRoomPlacementAttemptsFactor = 0.5;\nconst maximumDefaultRoomPlacementAttempts = 1000;\nconst NystromConfigFields = [\n    { name: \"roomPlacementAttempts\", parser: util_1.parseNumber },\n    { name: \"minRoomSize\", parser: common_1.Size.fromString },\n    { name: \"maxRoomSize\", parser: common_1.Size.fromString },\n];\n/**\n * Area generation algorithm based on this\n * {@link http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/ article}\n * by Bob Nystrom.\n *\n * Generates dense, perfect areas with rooms. Uses {@link RecursiveBacktracker} to\n * fill the space between rooms. For example:\n * ```\n * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n * ┃       #       #               ┃\n * ┃       #       # #   # # # #   ┃\n * ┃                           #   ┃\n * ┃ # # # #       #           #   ┃\n * ┃               #           #   ┃\n * ┃   # # # # # # #           #   ┃\n * ┃   #       #   #           #   ┃\n * ┃   #       #   # # # # # # #   ┃\n * ┃   #       #       #   #       ┃\n * ┃   # #   # #       #   #   # # ┃\n * ┃                   #           ┃\n * ┃ # #   #   # # #   # # # # #   ┃\n * ┃       #       #   #           ┃\n * ┃   # # #       #   #           ┃\n * ┃       #       #   #           ┃\n * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n * ```\n *\n * @see {@link NystromConfig} for the default configuration\n * @see {@link BreakPassages} to add cycles\n * @see {@link RemoveDeadends} to remove all or a percentage of deadends\n */\nexports.Nystrom = nystrom;\nbase_1.registerGenerator(\"Nystrom\", exports.Nystrom, NystromConfigFields);\nfunction nystrom(c) {\n    let config = new _NystromConfig(c);\n    const area = new area_1.Area(config.size, area_1.Tile.Wall);\n    for (let i = 0; i < config.roomPlacementAttempts; i++) {\n        tryToAddRoom(config, area);\n    }\n    carvePassages(area);\n    connectSections(area);\n    return area;\n}\nfunction tryToAddRoom(config, area) {\n    const room = randomRoom(config);\n    for (let point of room.points()) {\n        if (!area.contains(point) || area.get(point).passable) {\n            return;\n        }\n    }\n    room.forEach(p => area.set(p, area_1.Tile.Floor));\n}\nfunction randomRoom(config) {\n    const start = common_1.Vector.random(config.size, p => p.x % 2 === 0 && p.y % 2 === 0);\n    let size;\n    do {\n        // TODO Don't force odd room sizes, instead configure a minimum room distance\n        size = {\n            width: lodash_1.default.random(config.minRoomSize.width, config.maxRoomSize.width),\n            height: lodash_1.default.random(config.minRoomSize.height, config.maxRoomSize.height)\n        };\n    } while (size.width % 2 === 0 || size.height % 2 === 0);\n    return new common_1.Rectangle(start, size);\n}\nfunction carvePassages(area) {\n    let start;\n    do {\n        start = undefined;\n        for (let point of area.points()) {\n            if (!area.get(point).passable && point.x % 2 === 0 && point.y % 2 === 0) {\n                start = point;\n                break;\n            }\n        }\n        if (start !== undefined) {\n            simple_1.recursiveBacktrack(area, start);\n        }\n    } while (start !== undefined);\n}\nfunction connectSections(area) {\n    const sections = area_1.floodFill(area, t => t.passable);\n    while (sections.length > 1) {\n        const link = lodash_1.default.sample(findSectionLinks(area, sections));\n        area.set(link.point, area_1.Tile.Floor);\n        sections[link.section1].push(link.point, ...sections[link.section2]);\n        sections.splice(link.section2, 1);\n    }\n}\nfunction findSectionLinks(area, sections) {\n    const sectionIndex = (point) => {\n        for (let index = 0; index < sections.length; index++) {\n            const section = sections[index];\n            if (section.some(p => p.x === point.x && p.y === point.y)) {\n                return index;\n            }\n        }\n        return undefined;\n    };\n    const links = [];\n    for (let point of area.points()) {\n        if (!area.get(point).passable) {\n            let neighbours = area.neighbours(point, common_1.Direction.straights());\n            let passableCount = 0;\n            for (let directionName in neighbours) {\n                passableCount += neighbours[directionName].passable ? 1 : 0;\n            }\n            const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;\n            const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;\n            const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;\n            const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;\n            if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {\n                let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] :\n                    [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];\n                let section1 = sectionIndex(passable1);\n                let section2 = sectionIndex(passable2);\n                if (section1 !== section2) {\n                    links.push({\n                        point: point,\n                        section1: section1,\n                        section2: section2\n                    });\n                }\n            }\n        }\n    }\n    return links;\n}\nclass _NystromConfig {\n    constructor(config) {\n        this.size = config.size;\n        this.minRoomSize = config.minRoomSize || this.defaultMinRoomSize();\n        this.maxRoomSize = config.maxRoomSize || this.defaultMaxRoomSize();\n        this.roomPlacementAttempts = config.roomPlacementAttempts || Math.min(config.size.width * config.size.height * defaultRoomPlacementAttemptsFactor, maximumDefaultRoomPlacementAttempts);\n    }\n    defaultMinRoomSize() {\n        const baseSize = Math.round((this.size.width + this.size.height) * 0.5);\n        const width = baseSize * defaultMinSizeFactor;\n        const height = baseSize * defaultMinSizeFactor;\n        return {\n            width: Math.max(minMinRoomSize, width),\n            height: Math.max(minMinRoomSize, height)\n        };\n    }\n    defaultMaxRoomSize() {\n        const baseSize = Math.round((this.size.width + this.size.height) * 0.5);\n        const width = baseSize * defaultMaxSizeFactor;\n        const height = baseSize * defaultMaxSizeFactor;\n        return {\n            width: Math.max(minMaxRoomSize, width),\n            height: Math.max(minMaxRoomSize, height)\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"script"}