"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./domain/common");
const simple_1 = require("./generator/simple");
/**
 * Class defining the necessary configuration for {@link Amazer}.
 */
class Config {
    /**
     * @param size The size of the area to be generated
     * @param generator The generator algorithm to use
     * @param modifiers The modifiers to apply to the generated area. May be empty.
     */
    constructor(size, generator, modifiers) {
        this._size = size;
        this._generator = generator;
        this._modifiers = modifiers || [];
    }
    // TODO Allow simplified object
    // TODO Add docu
    static fromObject(data) {
        let modifiers = [];
        if (data.modifier !== undefined) {
            modifiers.push(...data.modifier);
        }
        if (data.modifiers !== undefined) {
            modifiers.push(...data.modifiers);
        }
        return new Config(common_1.Size.fromObject(data), data.generator || { generator: simple_1.RecursiveBacktracker, config: undefined }, modifiers);
    }
    get size() {
        return this._size;
    }
    get generator() {
        return this._generator;
    }
    get modifiers() {
        return this._modifiers;
    }
}
exports.Config = Config;
// TODO Allow simple values for configuration
/**
 * Builder for {@link Amazer amazer instances}.
 *
 * Example usage:
 * ```typescript
 * const amazer: Amazer = new ConfigBuilder()
 *      .withSize({width: 10, height: 10})
 *      .using(RandomizedPrim)
 *      .andModifier(Emmure)
 *      .andModifier(BreakPassages)
 *      .build()
 * ```
 */
class AmazerBuilder {
    constructor() {
        this._modifiers = [];
    }
    /**
     * Sets the areas size.
     *
     * @returns This instance for method chaining.
     */
    withSize(size) {
        this._size = size;
        return this;
    }
    /**
     * Sets the areas width.
     *
     * @returns This instance for method chaining.
     */
    withWidth(width) {
        if (this._size === undefined) {
            this._size = { width: 0, height: 0 };
        }
        this._size.width = width;
        return this;
    }
    /**
     * Sets the areas height.
     *
     * @returns This instance for method chaining.
     */
    withHeight(height) {
        if (this._size === undefined) {
            this._size = { width: 0, height: 0 };
        }
        this._size.width = height;
        return this;
    }
    /**
     * Sets the algorithm to generate the area and optionally its config.
     *
     * @param generator The algorithm to use
     * @param config The algorithms config
     *
     * @returns This instance for method chaining.
     */
    using(generator, config) {
        this._generator = { generator: generator, config: config };
        return this;
    }
    /**
     * Adds a modifier to be applied to generated areas and optionally its config.
     *
     * @param generator The modifier to add
     * @param config The modifiers config
     *
     * @returns This instance for method chaining.
     */
    andModifier(modifier, config) {
        this._modifiers.push({ modifier: modifier, config: config });
        return this;
    }
    /**
     * Creates a new {@link Amazer} with the current config. The builder can be used
     * afterwards to create additional instances without modifying the ones already created.
     *
     * @throws An error, if the size has not been set
     * @throws An error, if either width or height are 0
     * @throws An error, if no generator has been set
     */
    build() {
        if (this._size === undefined || this._size.height === 0 || this._size.width === 0) {
            throw new Error(`Invalid size ${this._size}: Must be set and have values > 0`);
        }
        if (this._generator === undefined) {
            throw new Error("No generator has been set");
        }
        return new Config(Object.assign({}, this._size), this._generator, [...this._modifiers]);
    }
    /**
     * Method stub to ease usage of {@link amazer amazer entrypoint}.
     *
     * @ignore
     */
    generate() {
        throw new Error("Not implemented");
    }
}
exports.AmazerBuilder = AmazerBuilder;
/**
 * Root class to generate {@link Area Areas}. Has a single config, but can be reused to generate
 * several areas.
 */
class Amazer {
    constructor(config) {
        this.config = config;
    }
    /**
     * Generate a new area.
     */
    generate() {
        const generatorConfig = Object.assign({ size: this.config.size }, this.config.generator.config);
        let area = this.config.generator.generator(generatorConfig);
        for (let m of this.config.modifiers) {
            area = m.modifier(area, Object.assign({}, m.config));
        }
        return area;
    }
}
exports.Amazer = Amazer;
/**
 * Global entrypoint for the amazer library.
 *
 * Creates a new {@link Amazer} instance for the given {@link Config} or a new {@link AmazerBuilder},
 * if no {@link Config} is provided.
 *
 * @param config The amazer config
 *
 * @returns A new {@link Amazer}, if a config is given, a new {@link AmazerBuilder} otherwhise.
 */
function amazer(config) {
    if (config === undefined) {
        return new AmazerBuilder();
    }
    else {
        return new Amazer(config);
    }
}
exports.default = amazer;
