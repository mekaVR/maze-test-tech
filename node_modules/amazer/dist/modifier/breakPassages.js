"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const area_1 = require("../domain/area");
const common_1 = require("../domain/common");
const solver_1 = require("../solver");
const util_1 = require("../util");
const BreakPassagesConfigFields = [
    { name: "amount", parser: util_1.parseNumber },
    { name: "minimumShortcutDistance", parser: util_1.parseNumber },
];
/**
 * Replaces {@link BreakPassagesConfig.amount} random wall tiles that have
 * exactly 2 floor tiles as neighbours with floor tiles. The path length
 * between the 2 floor tiles must be greater equals than
 * {@link BreakPassagesConfig.minimumShortcutDistance}.
 *
 * It is possible that less wall tiles than the targeted amount are replaced,
 * if the minimum shortcut distance is too large.
 *
 * Example:
 * ```
 * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓
 * ┃           ┃    ┃           ┃
 * ┃   # # # # ┃    ┃   #   # # ┃
 * ┃   #       ┃ => ┃   #       ┃
 * ┃   # # #   ┃    ┃   # # #   ┃
 * ┃           ┃    ┃           ┃
 * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛
 * ```
 *
 * @returns The same, but modified area instance.
 */
exports.BreakPassages = breakPassages;
base_1.registerModifier("BreakPassages", exports.BreakPassages, BreakPassagesConfigFields);
function breakPassages(area, config) {
    let amount = config.amount || (area.width + area.height) / 2;
    const minimumShortcutDistance = config.minimumShortcutDistance || Math.sqrt(area.width * area.height);
    const candidates = lodash_1.default.shuffle(findCandidates(area));
    while (amount >= 0 && candidates.length > 0) {
        const candidate = candidates.pop();
        const path = solver_1.findPath(area, candidate.neighbour1, candidate.neighbour2);
        if (path === undefined || path.length >= minimumShortcutDistance) {
            area.set(candidate.point, area_1.Tile.Floor);
            amount--;
        }
    }
    return area;
}
function findCandidates(area) {
    const candidates = [];
    for (let point of area.points()) {
        if (!area.get(point).passable) {
            let neighbours = area.neighbours(point, common_1.Direction.straights());
            let passableCount = 0;
            for (let directionName in neighbours) {
                passableCount += neighbours[directionName].passable ? 1 : 0;
            }
            const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;
            const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;
            const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;
            const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;
            if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {
                let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] :
                    [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];
                candidates.push(new PassageCandidate(point, passable1, passable2));
            }
        }
    }
    return candidates;
}
class PassageCandidate {
    constructor(point, neighbour1, neighbour2) {
        this.point = point;
        this.neighbour1 = neighbour1;
        this.neighbour2 = neighbour2;
    }
}
