"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
const area_1 = require("../domain/area");
const common_1 = require("../domain/common");
/**
 * Surrounds an area with a solid wall, which may increase the areas size.
 * This modifier has no separate config.
 *
 * Edges that already are solid (only consist of wall tiles) are skipped.
 *
 * Example:
 * ```
 *                 ┏━━━━━━━━━━━┓
 * ┏━━━━━━━━━┓     ┃ # # # # # ┃
 * ┃       # ┃     ┃ #       # ┃
 * ┃ # #   # ┃  => ┃ # # #   # ┃
 * ┃       # ┃     ┃ #       # ┃
 * ┃ # # # # ┃     ┃ # # # # # ┃
 * ┗━━━━━━━━━┛     ┗━━━━━━━━━━━┛
 * ```
 *
 * @returns A new {@link Area} instance that is completely surrounded
 *      by wall tiles.
 */
exports.Emmure = emmure;
base_1.registerModifier("Emmure", exports.Emmure);
function emmure(area, _) {
    let borders = {
        "Up": [new common_1.Vector(0, 0), common_1.Direction.Right],
        "Left": [new common_1.Vector(0, 0), common_1.Direction.Down],
        "Right": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Up],
        "Down": [new common_1.Vector(area.width - 1, area.height - 1), common_1.Direction.Left]
    };
    let wallsNeeded = {};
    for (let borderDirection in borders) {
        let [point, walkDirection] = borders[borderDirection];
        let needsWall = 0;
        while (area.contains(point)) {
            if (area.get(point).passable) {
                needsWall = 1;
                break;
            }
            point = point.translate(walkDirection);
        }
        wallsNeeded[borderDirection] = needsWall;
    }
    let xOffset = wallsNeeded["Left"];
    let yOffset = wallsNeeded["Up"];
    let emmuredArea = new area_1.Area({
        width: area.width + xOffset + wallsNeeded["Right"],
        height: area.height + yOffset + wallsNeeded["Down"]
    });
    area.forEach((t, p) => emmuredArea.set({ x: p.x + xOffset, y: p.y + yOffset }, t));
    for (let point of emmuredArea.points()) {
        if (emmuredArea.get(point) === area_1.Tile.Empty) {
            emmuredArea.set(point, area_1.Tile.Wall);
        }
    }
    return emmuredArea;
}
