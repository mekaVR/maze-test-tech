"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const area_1 = require("../domain/area");
const common_1 = require("../domain/common");
const util_1 = require("../util");
const RemoveDeadendsConfigFields = [
    { name: "deadendsToRemove", parser: util_1.parseNumber }
];
const DeadendTile = area_1.Tile.impassable("Deadend");
/**
 * Removes a targeted amount ({@link RemoveDeadendsConfig.deadendsToRemove see config})
 * of deadends (tiles with a single walkable neighbour), replacing them with wall tiles.
 *
 * Beware that using this modifier on an unmodified area generated by the built-in
 * algorithms will fill it completely with wall tiles, since all tiles will become
 * deadends.
 *
 * It is possible that less than the targeted amount of deadends removed, if no further
 * deadends exist.
 *
 * Example (removing 30% of the deadends):
 * ```
 * ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━┓
 * ┃       #   ┃    ┃ # # # #   ┃
 * ┃ # #   #   ┃    ┃ # # # #   ┃
 * ┃   #       ┃ => ┃   #       ┃
 * ┃   #   #   ┃    ┃   #   # # ┃
 * ┃       #   ┃    ┃       # # ┃
 * ┗━━━━━━━━━━━┛    ┗━━━━━━━━━━━┛
 * ```
 */
exports.RemoveDeadends = removeDeadends;
base_1.registerModifier("RemoveDeadends", exports.RemoveDeadends, RemoveDeadendsConfigFields);
function removeDeadends(area, config) {
    const collectedDeadends = [];
    const currentDeadends = lodash_1.default.shuffle(findDeadends(area));
    while (currentDeadends.length > 0) {
        const deadend = currentDeadends.pop();
        area.set(deadend.point, DeadendTile);
        collectedDeadends.push(deadend.point);
        if (deadend.passableDirection !== undefined) {
            const nextDeadend = asDeadend(area, deadend.point.translate(deadend.passableDirection));
            if (nextDeadend !== undefined) {
                currentDeadends.unshift(nextDeadend);
            }
        }
    }
    let deadendsToRemove = config.deadendsToRemove || 1;
    if (deadendsToRemove <= 1) {
        deadendsToRemove = deadendsToRemove * collectedDeadends.length;
    }
    for (let deadend of collectedDeadends) {
        const tile = deadendsToRemove > 0 ? area_1.Tile.Wall : area_1.Tile.Floor;
        area.set(deadend, tile);
        deadendsToRemove--;
    }
    return area;
}
function findDeadends(area) {
    const deadends = [];
    for (let point of area.points()) {
        if (area.get(point).passable) {
            const deadend = asDeadend(area, point);
            if (deadend !== undefined) {
                deadends.push(deadend);
            }
        }
    }
    return deadends;
}
function asDeadend(area, point) {
    const neighbours = area.neighbours(point, common_1.Direction.straights());
    let impassableCount = 0;
    let passableDirection = undefined;
    for (let direction of common_1.Direction.straights()) {
        const neighbour = neighbours[direction.name];
        if (neighbour === undefined || !neighbour.passable) {
            impassableCount++;
        }
        else {
            passableDirection = direction;
        }
    }
    return impassableCount >= 3 ? { point: point, passableDirection: passableDirection } : undefined;
}
