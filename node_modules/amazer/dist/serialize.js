"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const area_1 = require("./domain/area");
/**
 * Set of functions to serialize and deserialize {@link Area}.
 */
var serialize;
(function (serialize) {
    /**
     * Serializes the given {@link Area} {@link toBytes to bytes} and encodes
     * the data as base64.
     */
    function toBase64(area) {
        return Buffer.from(toBytes(area)).toString("base64");
    }
    serialize.toBase64 = toBase64;
    /**
     * Serializes the given {@link Area} to bytes.
     *
     * The first 4 byte represent the width and height. Each following bit
     * represents if the {@link Tile} is passable, going from `(0, 0)` to
     * `(width - 1, height - 1)`.
     */
    function toBytes(area) {
        return areaToBytes(area);
    }
    serialize.toBytes = toBytes;
    /**
     * Deserializes an {@link Area} from a base64 encoded string that was
     * serialized with {@link toBase64}.
     */
    function fromBase64(data) {
        return fromBytes(Buffer.from(data, "base64"));
    }
    serialize.fromBase64 = fromBase64;
    /**
     * Deserializes an {@link Area} from a byte array that was
     * serialized with {@link toBytes}.
     */
    function fromBytes(bytes) {
        return bytesToArea(bytes);
    }
    serialize.fromBytes = fromBytes;
})(serialize = exports.serialize || (exports.serialize = {}));
function areaToBytes(area) {
    const bytes = new Uint8Array(4 + Math.ceil((area.width * area.height) / 8));
    bytes.set(int16ToBytes(area.width), 0);
    bytes.set(int16ToBytes(area.height), 2);
    let index = 4;
    let bits = 0;
    let byte = 0;
    for (let y = 0; y < area.height; y++) {
        for (let x = 0; x < area.width; x++) {
            const tile = area.get({ x: x, y: y });
            if (bits === 8) {
                bytes[index] = byte;
                index++;
                bits = 0;
                byte = 0;
            }
            byte = (byte << 1) + (tile.passable ? 1 : 0);
            bits++;
        }
    }
    byte = byte << (8 - bits);
    bytes[index] = byte;
    return bytes;
}
function bytesToArea(bytes) {
    const area = new area_1.Area({
        width: bytesToNumber(bytes.subarray(0, 2)),
        height: bytesToNumber(bytes.subarray(2, 4))
    });
    const tileBytes = bytes.subarray(4);
    let tileIndex = 0;
    for (let i = 0; i < tileBytes.length && tileIndex < area.width * area.height; i++) {
        const byte = tileBytes[i];
        for (let b = 7; b >= 0 && tileIndex < area.width * area.height; b--) {
            const bit = (byte >> b) & 1;
            const tile = bit === 1 ? area_1.Tile.Floor : area_1.Tile.Wall;
            const tilePoint = {
                x: tileIndex % area.width,
                y: Math.floor(tileIndex / area.width)
            };
            area.set(tilePoint, tile);
            tileIndex++;
        }
    }
    return area;
}
function int16ToBytes(value) {
    const bytes = new Uint8Array([
        (value >> 8) & 255,
        value & 255
    ]);
    return bytes;
}
function bytesToNumber(bytes) {
    let value = bytes[0];
    for (let i = 1; i < bytes.length; i++) {
        value = value << 8;
        value += bytes[i];
    }
    return value;
}
exports.default = serialize;
