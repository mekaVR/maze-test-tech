"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./domain/common");
/**
 * Searches for the shortest path from `s` to `t` and returns a list of {@link Direction directions}
 * to get from `s` to `t` or `undefined`, if no path could be found.
 *
 * @param area The area to search
 * @param s The start point
 * @param t The target point
 * @param isWalkable Predicate to decide if a {@link Tile} can be walked. Defaults to {@link Tile.passable}.
 *
 * @returns A list of {@link Direction directions} to get from `s` to `t` or `undefined`, if no path could be found.
 */
function findPath(area, s, t, isWalkable) {
    isWalkable = isWalkable || (t => t.passable);
    const start = common_1.Vector.from(s);
    const target = common_1.Vector.from(t);
    const openNodes = [];
    const visited = [];
    for (let x = 0; x < area.width; x++) {
        visited.push(new Array(area.height).fill(false));
    }
    let finalNode = undefined;
    openNodes.push(createNode(start, 0, target));
    do {
        const node = openNodes.pop();
        if (node.point.equals(target)) {
            finalNode = node;
            break;
        }
        const neighbours = area.neighbours(node.point, common_1.Direction.straights());
        visited[node.point.x][node.point.y] = true;
        for (let name in neighbours) {
            const tile = neighbours[name];
            const direction = common_1.Direction.forName(name);
            const successorPoint = node.point.translate(direction);
            if (isWalkable(tile) && !visited[successorPoint.x][successorPoint.y]) {
                const successorIndex = openNodes.findIndex(n => n.point.equals(successorPoint));
                const successorNode = createNode(successorPoint, node.cost + 1, target, node, direction);
                if (successorIndex === -1) {
                    openNodes.push(successorNode);
                }
                else if (node.cost + 1 < openNodes[successorIndex].cost) {
                    openNodes[successorIndex] = successorNode;
                }
            }
        }
        openNodes.sort(compareNodes);
    } while (openNodes.length > 0);
    return finalNode === undefined ? undefined : buildPath(finalNode);
}
exports.findPath = findPath;
function createNode(point, cost, target, predecessor, direction) {
    return {
        point: point,
        cost: cost,
        distance: point.distance(target),
        predecessor: predecessor,
        direction: direction
    };
}
function compareNodes(node1, node2) {
    const v1 = node1.cost + node1.distance;
    const v2 = node2.cost + node2.distance;
    return (v1 - v2) * -1;
}
function buildPath(node) {
    const path = [];
    let currentNode = node;
    while (currentNode.predecessor !== undefined) {
        if (currentNode.direction === undefined) {
            throw new Error("Node in path does not have a direction");
        }
        path.push(currentNode.direction);
        currentNode = currentNode.predecessor;
    }
    return path;
}
