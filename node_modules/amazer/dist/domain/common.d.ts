import { Dict } from "../util";
export interface Size {
    width: number;
    height: number;
}
/** Utility functions for {@link Size} */
export declare namespace Size {
    /** Format `size` as a string: `<width>x<height>` */
    function stringify(size: Size): string;
    /**
     * Creates a new {@link Size} object from the given data.
     *
     * `data` must be an object with attribute `size` or
     * `width` **and** `height`. The value for `size` can
     * be a string parseable by {@link fromString} or another
     * object with `width` and `height` attributes.
     *
     * @throws An error, if the `data` has no size information.
     */
    function fromObject(data: Dict<any>): Size;
    /**
     * Creates a new {@link Size} object from the given string.
     *
     * The string must have the format `<width>x<height>`, where
     * width and height are valid numbers.
     *
     * @throws An error, if `value` does not match the format
     */
    function fromString(value: string): Size;
}
export interface Point {
    x: number;
    y: number;
}
/**
 * Extension class for {@link Point} providing additional
 * utility methods.
 */
export declare class Vector implements Point {
    readonly x: number;
    readonly y: number;
    constructor(x: number, y: number);
    /** Creates a new vector from the given {@link Point} */
    static from(point: Point): Vector;
    /**
     * Creates a random vector with `0 <= x < size.width` and
     * `0 <= y < size.height` that matches the given predicate.
     *
     * May result in an infinite loop, if `predicate` never returns
     * `true`.
     *
     * @param size The upper bound of the resulting vector
     * @param predicate Function that checks if a random point is valid.
     */
    static random(size: Size, predicate?: (p: Vector) => boolean): Vector;
    /**
     * Translates this vector by the given delta x and delta y
     * multiplied by `times`, creating a new vector instance.
     *
     * If `by` doesn't have `dx`/`dy` 0 is used.
     *
     * @param by The amount to move by
     * @param times Factor used to multiply `by` by
     *
     * @returns A new vector instance translated by `by * times`
     */
    translate(by: {
        dx?: number;
        dy?: number;
    }, times?: number): Vector;
    /** Calculated the euclidean distance to the given {@link Point}. */
    distance(other: Point): number;
    /**
     * Checks if `x` and `y` of the given {@link Point} are strictly
     * equal to this vector.
     */
    equals(other: Point): boolean;
}
export declare class Rectangle {
    readonly size: Size;
    readonly topLeft: Vector;
    readonly topRight: Vector;
    readonly bottomLeft: Vector;
    readonly bottomRight: Vector;
    /**
     * @param topLeft Top left coordinates of the rectangle
     * @param size Size of the rectangle
     */
    constructor(topLeft: Point, size: Size);
    readonly width: number;
    readonly height: number;
    intersect(other: Rectangle): boolean;
    /**
     * Generates all {@link Vector points} contained by this rectangle.
     */
    points(): Iterable<Vector>;
    forEach(consumer: (p: Vector) => void): void;
}
/** Utility class for the possible directions */
export declare class Direction {
    readonly name: string;
    readonly dx: number;
    readonly dy: number;
    private constructor();
    static readonly None: Direction;
    static readonly Up: Direction;
    static readonly UpRight: Direction;
    static readonly Right: Direction;
    static readonly DownRight: Direction;
    static readonly Down: Direction;
    static readonly DownLeft: Direction;
    static readonly Left: Direction;
    static readonly UpLeft: Direction;
    /**
     * @returns `true`, if the direction is strictly horizontal
     */
    isHorizontal(): boolean;
    /**
     * @returns `true`, if the direction is strictly vertical
     */
    isVertical(): boolean;
    /**
     * @returns `true`, if the direction is horizontal or vertical
     */
    isStraight(): boolean;
    /**
     * @returns `true`, if the direction is diagonal
     */
    isDiagonal(): boolean;
    /**
     * @returns The opposite if this direction.
     */
    opposite(): Direction;
    private static readonly _values;
    private static readonly _all;
    private static readonly _straights;
    private static readonly _diagonals;
    /**
     * @returns The direction for the given name
     *
     * @throws An error, if no direction for the name could be found
     */
    static forName(name: string): Direction;
    /**
     * @returns All directions, including the `None` direction
     */
    static values(): ReadonlyArray<Direction>;
    /**
     * @returns All actual directions (without the `None` direction)
     */
    static all(): ReadonlyArray<Direction>;
    /**
     * @returns All straight directions
     */
    static straights(): ReadonlyArray<Direction>;
    /**
     * @returns All diagonal directions
     */
    static diagonals(): ReadonlyArray<Direction>;
}
