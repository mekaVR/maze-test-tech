import { Size, Direction, Point, Vector } from "./common";
/**
 * Represents tiles inside an {@link Area}. Has a name for
 * identification and the information if it is passable or
 * not, which is used by several algorithms.
 *
 * Provides default instances for floor, wall and empty
 * tiles.
 */
export declare class Tile {
    readonly name: string;
    readonly passable: boolean;
    /** Default instance for empty, impassable tiles. */
    static readonly Empty: Tile;
    /** Default instance for passable tiles. */
    static readonly Floor: Tile;
    /** Default instance for impassable tiles. */
    static readonly Wall: Tile;
    private constructor();
    /**
     * Creates a new passable tile for the given name.
     */
    static passable(name: string): Tile;
    /**
     * Creates a new impassable tile for the given name.
     */
    static impassable(name: string): Tile;
}
export declare class Area {
    readonly tiles: Tile[][];
    /**
     * Creates a new area with the given {@link Size} filled
     * with {@link Tile tiles} given as `initialTile`.
     */
    constructor(size: Size, initialTile?: Tile);
    readonly width: number;
    readonly height: number;
    readonly size: Size;
    /**
     * Generates all {@link Vector points} contained by this area.
     */
    points(): Iterable<Vector>;
    /**
     * Generates all {@link Tile tile}, {@link Vector point} tuples
     * contained by this area.
     */
    cells(): Iterable<[Tile, Vector]>;
    /**
     * Performs the given action for all tiles contained by
     * this area.
     */
    forEach(consumer: (t: Tile, p: Vector) => void): void;
    get(point: Point): Tile;
    set(point: Point, tile: Tile): void;
    contains(point: Point): boolean;
    /**
     * Returns all {@link Neighbours} of `point` for the given
     * {@link Direction Directions}.
     *
     * @param point The point to get the nieghbours for
     * @param directions The directions to select the neighbours.
     *      Defaults to {@link Direction.all}.
     */
    neighbours(point: Vector, directions?: Iterable<Direction>): Neighbours;
    /**
     * Set all points containing {@link Tile.Empty} to the given {@link Tile}.
     */
    fill(tile: Tile): void;
}
/**
 * Indexable type with {@link Direction.name} as keys and the neighbour
 * {@link Tile} as values.
 */
export interface Neighbours {
    [direction: string]: Tile;
}
/**
 * Performs flood filling on the given {@link Area} using `predicate`
 * to determine if a {@link Tile} is walkable.
 *
 * Results in an array of *sections*, where a section is a set of
 * {@link Vector points} where any point has a path to any other point.
 * This means, that no section has a path to another section.
 *
 * @param area The area to flood fill
 * @param predicate A function to determine if a tile is walkable
 *
 * @returns A two-dimensional array of {@link Vector points}, representing
 *      the sections of the area.
 */
export declare function floodFill(area: Area, predicate: (t: Tile) => boolean): Array<Array<Vector>>;
