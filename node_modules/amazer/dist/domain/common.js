"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const util_1 = require("../util");
/** Utility functions for {@link Size} */
var Size;
(function (Size) {
    /** Format `size` as a string: `<width>x<height>` */
    function stringify(size) {
        return `${size.width}x${size.height}`;
    }
    Size.stringify = stringify;
    /**
     * Creates a new {@link Size} object from the given data.
     *
     * `data` must be an object with attribute `size` or
     * `width` **and** `height`. The value for `size` can
     * be a string parseable by {@link fromString} or another
     * object with `width` and `height` attributes.
     *
     * @throws An error, if the `data` has no size information.
     */
    function fromObject(data) {
        if (data.size !== undefined) {
            if (typeof data.size === "string") {
                return Size.fromString(data.size);
            }
            else {
                return { width: data.size.width, height: data.size.height };
            }
        }
        else if (data.width !== undefined && data.height !== undefined) {
            return { width: data.width, height: data.height };
        }
        else {
            throw new Error("No size information could be found");
        }
    }
    Size.fromObject = fromObject;
    /**
     * Creates a new {@link Size} object from the given string.
     *
     * The string must have the format `<width>x<height>`, where
     * width and height are valid numbers.
     *
     * @throws An error, if `value` does not match the format
     */
    function fromString(value) {
        let parts = value.split("x");
        if (parts.length != 2) {
            throw new Error(`The given value '${value}' does not match the required format WIDTHxHEIGHT`);
        }
        try {
            return { width: util_1.parseNumber(parts[0]), height: util_1.parseNumber(parts[1]) };
        }
        catch (error) {
            throw new Error(`The values of the given size '${value}' can not be parsed as number`);
        }
    }
    Size.fromString = fromString;
})(Size = exports.Size || (exports.Size = {}));
/**
 * Extension class for {@link Point} providing additional
 * utility methods.
 */
class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    /** Creates a new vector from the given {@link Point} */
    static from(point) {
        return new Vector(point.x, point.y);
    }
    /**
     * Creates a random vector with `0 <= x < size.width` and
     * `0 <= y < size.height` that matches the given predicate.
     *
     * May result in an infinite loop, if `predicate` never returns
     * `true`.
     *
     * @param size The upper bound of the resulting vector
     * @param predicate Function that checks if a random point is valid.
     */
    static random(size, predicate) {
        let point;
        do {
            point = new Vector(lodash_1.default.random(size.width - 1), lodash_1.default.random(size.height - 1));
        } while (predicate !== undefined && !predicate(point));
        return point;
    }
    /**
     * Translates this vector by the given delta x and delta y
     * multiplied by `times`, creating a new vector instance.
     *
     * If `by` doesn't have `dx`/`dy` 0 is used.
     *
     * @param by The amount to move by
     * @param times Factor used to multiply `by` by
     *
     * @returns A new vector instance translated by `by * times`
     */
    translate(by, times = 1) {
        return new Vector(this.x + (by.dx || 0) * times, this.y + (by.dy || 0) * times);
    }
    /** Calculated the euclidean distance to the given {@link Point}. */
    distance(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * Checks if `x` and `y` of the given {@link Point} are strictly
     * equal to this vector.
     */
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
}
exports.Vector = Vector;
class Rectangle {
    /**
     * @param topLeft Top left coordinates of the rectangle
     * @param size Size of the rectangle
     */
    constructor(topLeft, size) {
        this.size = size;
        this.topLeft = new Vector(topLeft.x, topLeft.y);
        this.topRight = new Vector(topLeft.x + size.width - 1, topLeft.y);
        this.bottomLeft = new Vector(topLeft.x, topLeft.y + size.height - 1);
        this.bottomRight = new Vector(topLeft.x + size.width - 1, topLeft.y + size.height - 1);
    }
    get width() {
        return this.size.width;
    }
    get height() {
        return this.size.height;
    }
    intersect(other) {
        return this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x
            && this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y;
    }
    /**
     * Generates all {@link Vector points} contained by this rectangle.
     */
    *points() {
        for (let x = this.topLeft.x; x <= this.bottomRight.x; x++) {
            for (let y = this.topLeft.y; y <= this.bottomRight.y; y++) {
                yield new Vector(x, y);
            }
        }
    }
    forEach(consumer) {
        for (let p of this.points()) {
            consumer(p);
        }
    }
}
exports.Rectangle = Rectangle;
/** Utility class for the possible directions */
class Direction {
    constructor(name, dx, dy) {
        this.name = name;
        this.dx = dx;
        this.dy = dy;
    }
    /**
     * @returns `true`, if the direction is strictly horizontal
     */
    isHorizontal() {
        if (this === Direction.Left || this === Direction.Right) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @returns `true`, if the direction is strictly vertical
     */
    isVertical() {
        if (this === Direction.Up || this === Direction.Down) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @returns `true`, if the direction is horizontal or vertical
     */
    isStraight() {
        return this.isHorizontal() || this.isVertical();
    }
    /**
     * @returns `true`, if the direction is diagonal
     */
    isDiagonal() {
        return Direction.diagonals().includes(this);
    }
    /**
     * @returns The opposite if this direction.
     */
    opposite() {
        let index = Direction.all().indexOf(this);
        return Direction.all()[(index + 4) % 8];
    }
    /**
     * @returns The direction for the given name
     *
     * @throws An error, if no direction for the name could be found
     */
    static forName(name) {
        let direction = Direction.values().find(d => d.name === name);
        if (direction === undefined) {
            throw new Error(`No direction available for name ${name}`);
        }
        return direction;
    }
    /**
     * @returns All directions, including the `None` direction
     */
    static values() {
        return Direction._values;
    }
    /**
     * @returns All actual directions (without the `None` direction)
     */
    static all() {
        return Direction._all;
    }
    /**
     * @returns All straight directions
     */
    static straights() {
        return Direction._straights;
    }
    /**
     * @returns All diagonal directions
     */
    static diagonals() {
        return Direction._diagonals;
    }
}
exports.Direction = Direction;
Direction.None = new Direction("None", 0, 0);
Direction.Up = new Direction("Up", 0, -1);
Direction.UpRight = new Direction("UpRight", 1, -1);
Direction.Right = new Direction("Right", 1, 0);
Direction.DownRight = new Direction("DownRight", 1, 1);
Direction.Down = new Direction("Down", 0, 1);
Direction.DownLeft = new Direction("DownLeft", -1, 1);
Direction.Left = new Direction("Left", -1, 0);
Direction.UpLeft = new Direction("UpLeft", -1, 1);
Direction._values = [
    Direction.None,
    Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight,
    Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft
];
Direction._all = [
    Direction.Up, Direction.UpRight, Direction.Right, Direction.DownRight,
    Direction.Down, Direction.DownLeft, Direction.Left, Direction.UpLeft
];
Direction._straights = [
    Direction.Up, Direction.Right, Direction.Down, Direction.Left
];
Direction._diagonals = [
    Direction.UpRight, Direction.DownRight, Direction.DownLeft, Direction.UpLeft
];
