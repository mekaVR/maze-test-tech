"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const util_1 = require("../util");
const _generators = {};
const _configFields = {};
/**
 * Registers the given {@link AreaGenerator} and the fields describing
 * its config (without the fields in {@link GeneratorConfig}). This allows
 * other utility methods to retrieve the registered generator and construct
 * its config.
 *
 * @see {@link generators}
 * @see {@link generator}
 * @see {@link parseGenerator}
 */
function registerGenerator(name, generator, configFields) {
    _generators[name] = generator;
    if (configFields !== undefined) {
        _configFields[name] = configFields;
    }
}
exports.registerGenerator = registerGenerator;
/**
 * @returns A list of all {@link registerGenerator registered} and their config
 *      {@link Field fields} (if provided) as tuples.
 */
function generators() {
    let result = [];
    for (let name in _generators) {
        result.push({
            name: name,
            generator: _generators[name],
            configFields: _configFields[name]
        });
    }
    return result;
}
exports.generators = generators;
/**
 * Parses the given data as {@link AreaGenerator} with config (if possible).
 *
 * The given data must be string with format `<generator name>[:<config data>]`
 * or an object, where the first key is the generator name and its value is
 * the config data.
 *
 * {@link configFrom} is used to create a config object from the config data.
 *
 * @param data The generator data to be parsed
 *
 * @throws An error, if the config data can not be parsed.
 */
function parseGenerator(data) {
    let generatorName;
    let configData;
    if (typeof data === "string") {
        const parts = data.split(":");
        generatorName = parts[0];
        configData = parts[1];
    }
    else {
        generatorName = Object.keys(data)[0];
        configData = data[generatorName];
    }
    const _generator = generator(generatorName);
    let config = undefined;
    if (configData !== undefined && _configFields.hasOwnProperty(_generator.name)) {
        try {
            config = util_1.configFrom(configData, _configFields[_generator.name]);
        }
        catch (error) {
            throw new Error(`Error parsing config for generator ${generatorName}: ${error.message}`);
        }
    }
    return { generator: _generator, config: config };
}
exports.parseGenerator = parseGenerator;
/**
 * @param name The algorithm name
 *
 * @returns The {@link AreaGenerator} with the given name.
 *
 * @throws An error, if no generator with the given name can be found.
 */
function generator(name) {
    const generator = _generators[name];
    if (generator === undefined) {
        throw new Error(`No generator with name ${name} could be found`);
    }
    return generator;
}
exports.generator = generator;
/**
 * Utility class representing a tile inside an area that has been
 * visitied, including the walkable directions outgoing from the tile.
 *
 * Used by several area generation algorithms.
 */
class VisitedTile {
    constructor(point, walkableDirections) {
        this.point = point;
        this.walkableDirections = lodash_1.default.shuffle(walkableDirections);
    }
    /**
     * @returns `true`, if there are walkable directions remaining.
     */
    hasNext() {
        return this.walkableDirections.length > 0;
    }
    /**
     * @returns The next walkable direction, moving the iterator forwards.
     *
     * @throws An error, if no walkable directions are left (see {@link hasNext}).
     */
    next() {
        let next = this.walkableDirections.pop();
        if (next === undefined) {
            throw new Error("No walkable directions left");
        }
        return next;
    }
}
exports.VisitedTile = VisitedTile;
