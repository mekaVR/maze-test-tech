import { Area } from "../domain/area";
import { Vector, Direction, Size } from "../domain/common";
import { Field } from "../util";
/**
 * Base interface containing all general {@link AreaGenerator} config
 * attributes.
 */
export interface GeneratorConfig {
    /** The size of the {@link Area} to generate. */
    readonly size: Size;
}
/** Functional interface for area generators. */
export interface AreaGenerator<C extends GeneratorConfig> {
    (config: C): Area;
}
/** Helper interface for an {@link AreaGenerator} and its config. */
export interface GeneratorWithConfig<C extends GeneratorConfig> {
    readonly generator: AreaGenerator<C>;
    readonly config?: C;
}
/** Helper interface for a registered {@link AreaGenerator}. */
export interface RegisteredGenerator<C extends GeneratorConfig> {
    readonly name: string;
    readonly generator: AreaGenerator<C>;
    readonly configFields?: Field[];
}
/**
 * Registers the given {@link AreaGenerator} and the fields describing
 * its config (without the fields in {@link GeneratorConfig}). This allows
 * other utility methods to retrieve the registered generator and construct
 * its config.
 *
 * @see {@link generators}
 * @see {@link generator}
 * @see {@link parseGenerator}
 */
export declare function registerGenerator(name: string, generator: AreaGenerator<any>, configFields?: Field[] | undefined): void;
/**
 * @returns A list of all {@link registerGenerator registered} and their config
 *      {@link Field fields} (if provided) as tuples.
 */
export declare function generators(): RegisteredGenerator<any>[];
/**
 * Parses the given data as {@link AreaGenerator} with config (if possible).
 *
 * The given data must be string with format `<generator name>[:<config data>]`
 * or an object, where the first key is the generator name and its value is
 * the config data.
 *
 * {@link configFrom} is used to create a config object from the config data.
 *
 * @param data The generator data to be parsed
 *
 * @throws An error, if the config data can not be parsed.
 */
export declare function parseGenerator<C extends GeneratorConfig>(data: any): GeneratorWithConfig<C>;
/**
 * @param name The algorithm name
 *
 * @returns The {@link AreaGenerator} with the given name.
 *
 * @throws An error, if no generator with the given name can be found.
 */
export declare function generator<C extends GeneratorConfig>(name: string): AreaGenerator<C>;
/**
 * Utility class representing a tile inside an area that has been
 * visitied, including the walkable directions outgoing from the tile.
 *
 * Used by several area generation algorithms.
 */
export declare class VisitedTile {
    readonly point: Vector;
    private readonly walkableDirections;
    constructor(point: Vector, walkableDirections: Iterable<Direction>);
    /**
     * @returns `true`, if there are walkable directions remaining.
     */
    hasNext(): boolean;
    /**
     * @returns The next walkable direction, moving the iterator forwards.
     *
     * @throws An error, if no walkable directions are left (see {@link hasNext}).
     */
    next(): Direction;
}
