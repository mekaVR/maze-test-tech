"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const area_1 = require("../domain/area");
const base_1 = require("./base");
const common_1 = require("../domain/common");
/**
 * Area generation algorithm using on a depth first
 * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker recursive backtracker}
 * algorithm. This algorithm has no separate config.
 *
 * Generates dense, perfect areas with low branching factor and
 * many long corridors. For example:
 * ```
 * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
 * ┃               #       #       ┃
 * ┃ # # # #   # # #   #   #   #   ┃
 * ┃           #       #       #   ┃
 * ┃   # # # # #   # # # # # # #   ┃
 * ┃   #       #               #   ┃
 * ┃   #   #   #   # # # # # # #   ┃
 * ┃       #   #   #           #   ┃
 * ┃   # # #   #   #   # # # # #   ┃
 * ┃       #   #   #           #   ┃
 * ┃ # #   #   #   # # # # #   #   ┃
 * ┃       #       #       #   #   ┃
 * ┃   # # # # # # # # #   #   #   ┃
 * ┃   #           #       #       ┃
 * ┃   # # #   #   #   #   # # # # ┃
 * ┃           #       #           ┃
 * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
 * ```
 */
exports.RecursiveBacktracker = recursiveBacktracker;
base_1.registerGenerator("RecursiveBacktracker", exports.RecursiveBacktracker);
function recursiveBacktracker(config) {
    const area = new area_1.Area(config.size, area_1.Tile.Wall);
    const start = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);
    recursiveBacktrack(area, start);
    return area;
}
/** @ignore */
function recursiveBacktrack(area, start) {
    let stack = [new base_1.VisitedTile(start, common_1.Direction.straights())];
    while (stack.length > 0) {
        let tile = stack.pop();
        area.set(tile.point, area_1.Tile.Floor);
        while (tile.hasNext()) {
            let direction = tile.next();
            let nextPoint = tile.point.translate(direction, 2);
            if (area.contains(nextPoint) && !area.get(nextPoint).passable) {
                area.set(tile.point.translate(direction), area_1.Tile.Floor);
                stack.push(tile);
                stack.push(new base_1.VisitedTile(nextPoint, common_1.Direction.straights()));
                break;
            }
        }
    }
}
exports.recursiveBacktrack = recursiveBacktrack;
/**
 * Area generation algorithm based on
 * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal's_algorithm Randomized Kruskal's}.
 * This algorithm has no separate config.
 *
 * Generates dense, perfect areas with high branching factor and
 * many deadends that are easy to solve. For example:
 * ```
 * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
 * ┃                           #   ┃
 * ┃ # #   # # # # # # #   # # #   ┃
 * ┃   #       #       #   #       ┃
 * ┃   # # #   # # #   # # #   # # ┃
 * ┃       #   #                   ┃
 * ┃   #   #   #   # # # # #   # # ┃
 * ┃   #           #       #       ┃
 * ┃ # #   #   #   # # #   #   #   ┃
 * ┃   #   #   #       #   #   #   ┃
 * ┃   # # # # # # #   #   # # # # ┃
 * ┃                               ┃
 * ┃ # #   # # #   # # # # # # # # ┃
 * ┃       #                       ┃
 * ┃ # # # # # #   # # # # # # #   ┃
 * ┃               #               ┃
 * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
 * ```
 */
exports.RandomizedKruskal = randomizedKruskal;
base_1.registerGenerator("RandomizedKruskal", exports.RandomizedKruskal);
function randomizedKruskal(config) {
    const area = new area_1.Area(config.size);
    const subSets = [];
    let walls = [];
    for (let point of area.points()) {
        if (point.x % 2 == 1 || point.y % 2 == 1) {
            area.set(point, area_1.Tile.Wall);
            walls.push(new base_1.VisitedTile(point, [common_1.Direction.Up, common_1.Direction.Right]));
        }
        else {
            area.set(point, area_1.Tile.Floor);
            let subSet = new Set();
            subSet.add(point);
            subSets.push(subSet);
        }
    }
    walls = lodash_1.default.shuffle(walls);
    const findSubSet = (p) => {
        for (let s of subSets) {
            for (let pS of s) {
                if (lodash_1.default.isEqual(p, pS)) {
                    return s;
                }
            }
        }
        return undefined;
    };
    while (walls.length > 0) {
        let wall = walls.pop();
        if (wall.hasNext()) {
            let direction = wall.next();
            let set1 = findSubSet(wall.point.translate(direction));
            let set2 = findSubSet(wall.point.translate(direction.opposite()));
            if (set1 !== undefined && set2 !== undefined && set1 !== set2) {
                area.set(wall.point, area_1.Tile.Floor);
                set2.forEach(p => set1.add(p));
                lodash_1.default.remove(subSets, s => s === set2);
            }
            walls.push(wall);
        }
        walls = lodash_1.default.shuffle(walls);
    }
    return area;
}
/**
 * Area generation algorithm based on
 * {@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim's_algorithm Randomized Prim's}.
 * This algorithm has no separate config.
 *
 * Generates dense, perfect areas with high branching factor and
 * many deadends that are easy to solve. For example:
 * ```
 * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
 * ┃   #   #   #           #   #   ┃
 * ┃   #   #   # # #   # # #   #   ┃
 * ┃           #   #           #   ┃
 * ┃ # # # #   #   # # #   # # #   ┃
 * ┃                       #   #   ┃
 * ┃ # # # # # # # #   #   #   #   ┃
 * ┃   #       #       #   #       ┃
 * ┃   # # #   # # #   # # #   # # ┃
 * ┃   #   #   #   #       #       ┃
 * ┃   #   #   #   #   # # # # #   ┃
 * ┃   #   #   #           #       ┃
 * ┃   #   #   # # #   # # #   # # ┃
 * ┃           #                   ┃
 * ┃ # # # #   # # #   #   #   # # ┃
 * ┃                   #   #       ┃
 * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
 * ```
 */
exports.RandomizedPrim = randomizedPrim;
base_1.registerGenerator("RandomizedPrim", exports.RandomizedPrim);
function randomizedPrim(config) {
    const area = new area_1.Area(config.size, area_1.Tile.Wall);
    const walls = [];
    const point = common_1.Vector.random(area.size, p => p.x % 2 == 0 && p.y % 2 == 0);
    area.set(point, area_1.Tile.Floor);
    // TODO Remove duplicated code
    common_1.Direction.straights().forEach(d => {
        const p = point.translate(d);
        if (area.contains(p)) {
            walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));
        }
    });
    while (walls.length > 0) {
        let index = lodash_1.default.random(walls.length - 1);
        let wall = walls[index];
        let direction = wall.next();
        let neighbour1 = wall.point.translate(direction);
        let neighbour2 = wall.point.translate(direction.opposite());
        if (area.contains(neighbour1) && area.contains(neighbour2) && area.get(neighbour1).passable !== area.get(neighbour2).passable) {
            let unvisited = area.get(neighbour1).passable ? neighbour2 : neighbour1;
            area.set(wall.point, area_1.Tile.Floor);
            area.set(unvisited, area_1.Tile.Floor);
            // TODO Remove duplicated code
            common_1.Direction.straights().forEach(d => {
                const p = unvisited.translate(d);
                if (area.contains(p)) {
                    walls.push(new base_1.VisitedTile(p, [common_1.Direction.Up, common_1.Direction.Right]));
                }
            });
        }
        if (!wall.hasNext()) {
            walls.splice(index, 1);
        }
    }
    return area;
}
/**
 * Generates a completely random {@link Area}, where each
 * tile has a 50/50 change to be floor or wall.
 */
exports.RandomArea = random;
base_1.registerGenerator("RandomArea", exports.RandomArea);
function random(config) {
    const area = new area_1.Area(config.size);
    let points = lodash_1.default.shuffle(Array.from(area.points()));
    points.forEach(p => area.set(p, lodash_1.default.random() > 0.5 ? area_1.Tile.Floor : area_1.Tile.Wall));
    return area;
}
