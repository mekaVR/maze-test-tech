"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const area_1 = require("../domain/area");
const common_1 = require("../domain/common");
const simple_1 = require("./simple");
const util_1 = require("../util");
const defaultMinSizeFactor = 0.04;
const defaultMaxSizeFactor = 0.1;
const minMinRoomSize = 3;
const minMaxRoomSize = 5;
const defaultRoomPlacementAttemptsFactor = 0.5;
const maximumDefaultRoomPlacementAttempts = 1000;
const NystromConfigFields = [
    { name: "roomPlacementAttempts", parser: util_1.parseNumber },
    { name: "minRoomSize", parser: common_1.Size.fromString },
    { name: "maxRoomSize", parser: common_1.Size.fromString },
];
/**
 * Area generation algorithm based on this
 * {@link http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/ article}
 * by Bob Nystrom.
 *
 * Generates dense, perfect areas with rooms. Uses {@link RecursiveBacktracker} to
 * fill the space between rooms. For example:
 * ```
 * ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
 * ┃       #       #               ┃
 * ┃       #       # #   # # # #   ┃
 * ┃                           #   ┃
 * ┃ # # # #       #           #   ┃
 * ┃               #           #   ┃
 * ┃   # # # # # # #           #   ┃
 * ┃   #       #   #           #   ┃
 * ┃   #       #   # # # # # # #   ┃
 * ┃   #       #       #   #       ┃
 * ┃   # #   # #       #   #   # # ┃
 * ┃                   #           ┃
 * ┃ # #   #   # # #   # # # # #   ┃
 * ┃       #       #   #           ┃
 * ┃   # # #       #   #           ┃
 * ┃       #       #   #           ┃
 * ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
 * ```
 *
 * @see {@link NystromConfig} for the default configuration
 * @see {@link BreakPassages} to add cycles
 * @see {@link RemoveDeadends} to remove all or a percentage of deadends
 */
exports.Nystrom = nystrom;
base_1.registerGenerator("Nystrom", exports.Nystrom, NystromConfigFields);
function nystrom(c) {
    let config = new _NystromConfig(c);
    const area = new area_1.Area(config.size, area_1.Tile.Wall);
    for (let i = 0; i < config.roomPlacementAttempts; i++) {
        tryToAddRoom(config, area);
    }
    carvePassages(area);
    connectSections(area);
    return area;
}
function tryToAddRoom(config, area) {
    const room = randomRoom(config);
    for (let point of room.points()) {
        if (!area.contains(point) || area.get(point).passable) {
            return;
        }
    }
    room.forEach(p => area.set(p, area_1.Tile.Floor));
}
function randomRoom(config) {
    const start = common_1.Vector.random(config.size, p => p.x % 2 === 0 && p.y % 2 === 0);
    let size;
    do {
        // TODO Don't force odd room sizes, instead configure a minimum room distance
        size = {
            width: lodash_1.default.random(config.minRoomSize.width, config.maxRoomSize.width),
            height: lodash_1.default.random(config.minRoomSize.height, config.maxRoomSize.height)
        };
    } while (size.width % 2 === 0 || size.height % 2 === 0);
    return new common_1.Rectangle(start, size);
}
function carvePassages(area) {
    let start;
    do {
        start = undefined;
        for (let point of area.points()) {
            if (!area.get(point).passable && point.x % 2 === 0 && point.y % 2 === 0) {
                start = point;
                break;
            }
        }
        if (start !== undefined) {
            simple_1.recursiveBacktrack(area, start);
        }
    } while (start !== undefined);
}
function connectSections(area) {
    const sections = area_1.floodFill(area, t => t.passable);
    while (sections.length > 1) {
        const link = lodash_1.default.sample(findSectionLinks(area, sections));
        area.set(link.point, area_1.Tile.Floor);
        sections[link.section1].push(link.point, ...sections[link.section2]);
        sections.splice(link.section2, 1);
    }
}
function findSectionLinks(area, sections) {
    const sectionIndex = (point) => {
        for (let index = 0; index < sections.length; index++) {
            const section = sections[index];
            if (section.some(p => p.x === point.x && p.y === point.y)) {
                return index;
            }
        }
        return undefined;
    };
    const links = [];
    for (let point of area.points()) {
        if (!area.get(point).passable) {
            let neighbours = area.neighbours(point, common_1.Direction.straights());
            let passableCount = 0;
            for (let directionName in neighbours) {
                passableCount += neighbours[directionName].passable ? 1 : 0;
            }
            const up = neighbours[common_1.Direction.Up.name] || area_1.Tile.Empty;
            const down = neighbours[common_1.Direction.Down.name] || area_1.Tile.Empty;
            const left = neighbours[common_1.Direction.Left.name] || area_1.Tile.Empty;
            const right = neighbours[common_1.Direction.Right.name] || area_1.Tile.Empty;
            if (passableCount === 2 && (up.passable && down.passable) !== (left.passable && right.passable)) {
                let [passable1, passable2] = up.passable ? [point.translate(common_1.Direction.Up), point.translate(common_1.Direction.Down)] :
                    [point.translate(common_1.Direction.Left), point.translate(common_1.Direction.Right)];
                let section1 = sectionIndex(passable1);
                let section2 = sectionIndex(passable2);
                if (section1 !== section2) {
                    links.push({
                        point: point,
                        section1: section1,
                        section2: section2
                    });
                }
            }
        }
    }
    return links;
}
class _NystromConfig {
    constructor(config) {
        this.size = config.size;
        this.minRoomSize = config.minRoomSize || this.defaultMinRoomSize();
        this.maxRoomSize = config.maxRoomSize || this.defaultMaxRoomSize();
        this.roomPlacementAttempts = config.roomPlacementAttempts || Math.min(config.size.width * config.size.height * defaultRoomPlacementAttemptsFactor, maximumDefaultRoomPlacementAttempts);
    }
    defaultMinRoomSize() {
        const baseSize = Math.round((this.size.width + this.size.height) * 0.5);
        const width = baseSize * defaultMinSizeFactor;
        const height = baseSize * defaultMinSizeFactor;
        return {
            width: Math.max(minMinRoomSize, width),
            height: Math.max(minMinRoomSize, height)
        };
    }
    defaultMaxRoomSize() {
        const baseSize = Math.round((this.size.width + this.size.height) * 0.5);
        const width = baseSize * defaultMaxSizeFactor;
        const height = baseSize * defaultMaxSizeFactor;
        return {
            width: Math.max(minMaxRoomSize, width),
            height: Math.max(minMaxRoomSize, height)
        };
    }
}
